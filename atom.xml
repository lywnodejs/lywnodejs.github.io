<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小世界</title>
  
  <subtitle>web前端开发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-22T05:16:22.239Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lyw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack配置</title>
    <link href="http://yoursite.com/webpack%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/webpack配置/</id>
    <published>2017-04-20T09:30:46.000Z</published>
    <updated>2018-05-22T05:16:22.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack配置官网"><a href="#webpack配置官网" class="headerlink" title="webpack配置官网"></a>webpack配置官网</h1><blockquote><p>webpack官网地址: <a href="https://www.webpackjs.com" target="_blank" rel="noopener">https://www.webpackjs.com</a><br>此教程项目地址:  <a href="https://github.com/lywnodejs/new/tree/master/webpack4.7" target="_blank" rel="noopener">https://github.com/lywnodejs/new/tree/master/webpack4.7</a> (拿到之后下载依赖 npm install)</p></blockquote><blockquote><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle</p></blockquote><ul><li>从 webpack v4.0.0 开始，可以不用引入一个配置文件。然而，webpack 仍然还是高度可配置的。在开始前你需要先理解四个核心概念：</li></ul><blockquote><p>入口(entry)<br>输出(output)<br>loader<br>插件(plugins)</p></blockquote><hr><h1 id="入口-amp-输出"><a href="#入口-amp-输出" class="headerlink" title="入口&amp;输出"></a>入口&amp;输出</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">path</span>=<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">module.exports=&#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        index:<span class="built_in">path</span>.join(__dirname,<span class="string">'src/scripts/index.js'</span>),</span><br><span class="line">        index2:<span class="built_in">path</span>.join(__dirname,<span class="string">'src/scripts/index2.js'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">output</span>:&#123;</span><br><span class="line">        <span class="built_in">path</span>:<span class="built_in">path</span>.join(__dirname,<span class="string">'dist/js'</span>),</span><br><span class="line">        filename:<span class="string">'[name]-[chunkhash].js'</span>  //hash为本次打包的hash值  [chunkhash] 为保证文件唯一性，可以认为是文件的版本号</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//打包单个</span><br><span class="line">    entry:&#123;</span><br><span class="line">        index:<span class="string">"./src/scripts/index.js"</span>,</span><br><span class="line">        index2:<span class="string">"./src/scripts/index2.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">  或者：entry:[<span class="string">"src/script/index.js"</span>.<span class="string">"src/script/index2.js"</span>]</span><br><span class="line">     <span class="built_in">output</span>:&#123;</span><br><span class="line">        filename:<span class="string">'dist/js/index.js'</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行webpack<br>不想用webpack.config.js作为配置文件  可以在npm命令行中输入 webapck –config webpack.dev.config.js 此处webpack.dev.config.js为文件名<br>配合npm 执行webpack ：在package.json中的scripts对象中添加“build”：“webpack –config webpack.config.js –progress –display-module –colors –display-reason”<br><img src="http://chuantu.biz/t6/316/1526958897x-1566688562.png" alt="img"></p></blockquote><hr><h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p>打包之后的HTML文件会自动插入打包后的js文件。如果html文件地址不对，请把output改为path:path.join(__dirname,’dist/‘)<br>想要使src下的HTML与打包后的HTML文件相关联  html-webpack-plugin中传参数<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">htmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attribute">template</span>:<span class="string">'./src/index.html'</span>,<span class="comment">//模板文件</span></span><br><span class="line">    <span class="attribute">filename</span>:<span class="string">'index.html'</span>,<span class="comment">//输出html文件，同样可以指定文件名，设置hash值</span></span><br><span class="line">    <span class="attribute">inject</span>:false,<span class="comment">//将脚本放入head还是body</span></span><br><span class="line">    <span class="attribute">title</span>:<span class="string">"webpack-app"</span>,<span class="comment">//html的标题 同时要在hmtl模板中的title中加入&lt;%= htmlWebpackpligin.options.title %&gt;此处必须是驼峰式命名，不然会报错</span></span><br><span class="line">    <span class="attribute">date</span>:new Date(),</span><br><span class="line">    <span class="attribute">minify</span>:&#123;</span><br><span class="line">        <span class="attribute">removeComments</span>:true,<span class="comment">//删除注释</span></span><br><span class="line">        <span class="attribute">collapseWhitespace</span>:true <span class="comment">//删除空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>多页面时 要分别引入不同的js文件 :<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">htmlWebpackPlugin</span>(&#123;</span><br><span class="line">        <span class="attribute">template</span>:<span class="string">'./src/index.html'</span>,<span class="comment">//模板文件</span></span><br><span class="line">        <span class="attribute">filename</span>:<span class="string">'index.html'</span>,<span class="comment">//同样可以指定文件名，设置hash值</span></span><br><span class="line">        <span class="attribute">inject</span>:<span class="string">'body'</span>,<span class="comment">//将脚本放入head还是body</span></span><br><span class="line">        <span class="attribute">title</span>:<span class="string">"webpack-app"</span>,<span class="comment">//html的标题同时要在hmtl模板中的title中加入&lt;%=htmlWebpackpligin.options.title%&gt;此处必须是驼峰式命名，不然会报错</span></span><br><span class="line">        <span class="attribute">chunks</span>:[<span class="string">'index'</span>],<span class="comment">//引入不同的脚本</span></span><br><span class="line">        <span class="attribute">excluedChunks</span>:[a,c]排除不引用的脚本</span><br><span class="line">    &#125;),</span><br><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">htmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attribute">template</span>:<span class="string">'./src/index2.html'</span>,</span><br><span class="line">    <span class="attribute">filename</span>:<span class="string">'index2.html'</span>,</span><br><span class="line">    <span class="attribute">inject</span>:<span class="string">'body'</span>,</span><br><span class="line">    <span class="attribute">title</span>:<span class="string">"webpack-app2"</span>,</span><br><span class="line">    <span class="attribute">chunks</span>:[<span class="string">'index'</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>将脚本直接写入html中<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">%=</span> <span class="attr">compilation.assets</span>[<span class="attr">htmlWebpackPlugin.files.chunks.index2.entry.substr</span>(<span class="attr">htmlWebpackPlugin.files.publicPath.length</span>)]<span class="attr">.source</span>() %&gt;</span></span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><hr><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>安装：npm install –save-dev babel-loader babel-core<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">module</span>:&#123;</span><br><span class="line">     <span class="attribute">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            use: <span class="string">'babel-loader'</span>,</span><br><span class="line">            include: path.<span class="built_in">resolve</span>(__dirname,<span class="string">'src'</span>),//加载哪个文件夹</span><br><span class="line">            exclude: path.<span class="built_in">resolve</span>(__dirname,<span class="string">'node_modules'</span>)//排除哪个文件夹</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="style-loader-css-loader-postcss-loader"><a href="#style-loader-css-loader-postcss-loader" class="headerlink" title="style-loader!css-loader!postcss-loader"></a>style-loader!css-loader!postcss-loader</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">test</span>: /\.css$/,</span><br><span class="line">    use:[</span><br><span class="line">        &#123;loader:<span class="string">'style-loader'</span>&#125;,</span><br><span class="line">        &#123;<span class="attribute">loader</span>:<span class="string">'css-loader'</span>,options:&#123;improtLoaders:<span class="number">1</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="attribute">loader</span>: <span class="string">"postcss-loader"</span>,options:&#123; plugins:[<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]&#125;&#125;,                    </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动加浏览器前缀 postcss-loader &gt;autoprefixer 需要npm下载</p><hr><h2 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h2><blockquote><p>打包less文件  npm install less less-loader –save-dev<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">test</span>:/\.less$/,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;loader: <span class="string">"style-loader"</span>&#125;,</span><br><span class="line">        &#123;<span class="attribute">loader</span>: <span class="string">"css-loader"</span>&#125;,</span><br><span class="line">        &#123;<span class="attribute">loader</span>: <span class="string">"postcss-loader"</span>,options:&#123; plugins:[<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]&#125;&#125;,</span><br><span class="line">        &#123;<span class="attribute">loader</span>: <span class="string">"less-loader"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>打包sass和less一样</p></blockquote><hr><h2 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h2><blockquote><p>打包html模板文件 npm install html-loader –save-dev<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">test</span>:/\.html$/,</span><br><span class="line">    use:[</span><br><span class="line">        &#123;loader:<span class="string">'html-loader'</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="img-loader-amp-file-loader"><a href="#img-loader-amp-file-loader" class="headerlink" title="img-loader &amp; file-loader"></a>img-loader &amp; file-loader</h2><p>打包之前压缩图片   npm install image-webpack-loader –save-dev<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attribute">test</span>:/\.(png|gif|svg|jpg)$/i,</span><br><span class="line">use:[</span><br><span class="line">    &#123;</span><br><span class="line">        loader:<span class="string">'url-loader'</span>,</span><br><span class="line">        options:&#123;</span><br><span class="line">            limit:<span class="number">10000</span>,</span><br><span class="line">            name:<span class="string">'images/[name].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">loader</span>:<span class="string">'image-webpack-loader'</span>,</span><br><span class="line">        options:&#123;</span><br><span class="line">            mozjpeg: &#123;</span><br><span class="line">                progressive: true,</span><br><span class="line">                quality: <span class="number">65</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="selector-tag">optipng</span>: &#123;</span><br><span class="line">                <span class="attribute">enabled</span>: false,</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="selector-tag">pngquant</span>: &#123;</span><br><span class="line">                <span class="attribute">quality</span>: <span class="string">'65-90'</span>,</span><br><span class="line">                speed: <span class="number">4</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="selector-tag">gifsicle</span>: &#123;</span><br><span class="line">                <span class="attribute">interlaced</span>: false,</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="selector-tag">webp</span>: &#123;</span><br><span class="line">                <span class="attribute">quality</span>: <span class="number">75</span></span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h1 id="以上教程根据webpack-4-7编写-亲测有效"><a href="#以上教程根据webpack-4-7编写-亲测有效" class="headerlink" title="以上教程根据webpack-4.7编写,亲测有效"></a>以上教程根据webpack-4.7编写,亲测有效</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack配置官网&quot;&gt;&lt;a href=&quot;#webpack配置官网&quot; class=&quot;headerlink&quot; title=&quot;webpack配置官网&quot;&gt;&lt;/a&gt;webpack配置官网&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;webpack官网地址: &lt;a href=
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="前端模块化开发" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>vue中的路由懒加载</title>
    <link href="http://yoursite.com/vue%E7%9A%84%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/vue的路由懒加载/</id>
    <published>2017-03-15T09:30:46.000Z</published>
    <updated>2018-05-23T02:04:24.714Z</updated>
    
    <content type="html"><![CDATA[<p>##<br>懒加载：<br>       也叫延迟加载，即在需要的时候进行加载，随用随载。</p><p>为什么需要懒加载？<br>　　　　像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时</p><p>　　　　简单的说就是：进入首页不用一次加载过多资源造成用时过长！！！</p><p>如何实现？</p><h1 id="懒加载写法："><a href="#懒加载写法：" class="headerlink" title="懒加载写法："></a>懒加载写法：</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      component:<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">require</span>([<span class="string">"@/components/login"</span>],resolve)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/list'</span>,</span><br><span class="line">      component:<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">require</span>([<span class="string">"@/components/list/list"</span>],resolve),</span><br><span class="line">      children:[</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'CuserManagement'</span>,</span><br><span class="line">          name:<span class="string">"C端用户管理"</span>,</span><br><span class="line">          component:<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">require</span>([<span class="string">"@/components/CuserManagement"</span>],resolve)       </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'BuserManagement'</span>,</span><br><span class="line">          name:<span class="string">"B端用户管理"</span>,</span><br><span class="line">          component:<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">require</span>([<span class="string">"@/components/BuserManagement"</span>],resolve)</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##&lt;br&gt;懒加载：&lt;br&gt;       也叫延迟加载，即在需要的时候进行加载，随用随载。&lt;/p&gt;
&lt;p&gt;为什么需要懒加载？&lt;br&gt;　　　　像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue中监听router变化</title>
    <link href="http://yoursite.com/vue%E7%9A%84router%E7%9B%91%E5%90%AC/"/>
    <id>http://yoursite.com/vue的router监听/</id>
    <published>2017-03-10T09:30:46.000Z</published>
    <updated>2018-05-21T08:44:20.955Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们需要监听路由，做出某种操作。。</p><p>##<br>下面是个简单的例子</p><p>##<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span>//添加到页面</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">export default&#123;</span></span><br><span class="line"><span class="xml">    data()&#123;</span></span><br><span class="line"><span class="xml">        return &#123;</span></span><br><span class="line"><span class="xml">            msg:""</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    mounted()&#123;</span></span><br><span class="line"><span class="xml">        this.get()</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    methods:&#123;</span></span><br><span class="line"><span class="xml">        get()&#123;</span></span><br><span class="line"><span class="xml">            this.msg=this.$router.history.current.name</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    watch:&#123;</span></span><br><span class="line"><span class="xml">        $route:"get" //监听router变化 并立即改变data数据</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">//其中this.$router.history.current是当前路由 下面的参数根据需要变化</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>还有其他封装方法 不一一列出了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候我们需要监听路由，做出某种操作。。&lt;/p&gt;
&lt;p&gt;##&lt;br&gt;下面是个简单的例子&lt;/p&gt;
&lt;p&gt;##&lt;br&gt;&lt;figure class=&quot;highlight django&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="router" scheme="http://yoursite.com/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>attr prop 区别</title>
    <link href="http://yoursite.com/attrAndProp/"/>
    <id>http://yoursite.com/attrAndProp/</id>
    <published>2017-02-27T01:58:40.000Z</published>
    <updated>2018-05-21T08:10:56.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jquery中attr和prop的区别"><a href="#jquery中attr和prop的区别" class="headerlink" title="jquery中attr和prop的区别"></a>jquery中attr和prop的区别</h1><p>在高版本的jquery引入prop方法后，什么时候该用prop？什么时候用attr？它们两个之间有什么区别？这些问题就出现了。</p><p>对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。<br>对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。</p><p>举几个例子就知道了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"http://www.baidu.com"</span> target=<span class="string">"_self"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn"</span>&gt;百度&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p> 这个例子里<code>&lt;a&gt;</code>元素的DOM属性有“<code>href、target</code>和<code>class</code>“，这些属性就是<code>&lt;a&gt;</code>元素本身就带有的属性，也是W3C标准里就包含有这几个属性，或者说在IDE里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用<code>prop</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span> id=<span class="string">"link1"</span> action=<span class="string">"delete"</span>&gt;删除&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子里<code>&lt;a&gt;</code>元素的DOM属性有“<code>href、id</code>和<code>action</code>”，很明显，前两个是固有属性，而后面一个“<code>action</code>”属性是我们自己自定义上去的，<code>&lt;a&gt;</code>元素本身是没有这个属性的。这种就是自定义的DOM属性。处理这些属性时，建议使用<code>attr</code>方法。使用<code>prop</code>方法取值和设置属性值时，都会返回<code>undefined</code>值。</p><p>再举一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"chk1"</span> type=<span class="string">"checkbox"</span> /&gt; <span class="comment">//是否可见</span></span><br><span class="line">&lt;input id=<span class="string">"chk2"</span> type=<span class="string">"checkbox"</span> checked=<span class="string">"checked"</span> /&gt; <span class="comment">//是否可见</span></span><br></pre></td></tr></table></figure><p>像<code>checkbox，radio</code>和<code>select</code>这样的元素，选中属性对应“<code>checked</code>”和“<code>selected</code>”，这些也属于固有属性，因此需要使用<code>prop</code>方法去操作才能获得正确的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#chk1"</span>).prop(<span class="string">"checked"</span>) == <span class="literal">false</span></span><br><span class="line">$(<span class="string">"#chk2"</span>).prop(<span class="string">"checked"</span>) == <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果上面使用<code>attr</code>方法，则会出现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#chk1"</span>).attr(<span class="string">"checked"</span>) == <span class="literal">undefined</span></span><br><span class="line">$(<span class="string">"#chk2"</span>).attr(<span class="string">"checked"</span>) == <span class="string">"checked"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jquery中attr和prop的区别&quot;&gt;&lt;a href=&quot;#jquery中attr和prop的区别&quot; class=&quot;headerlink&quot; title=&quot;jquery中attr和prop的区别&quot;&gt;&lt;/a&gt;jquery中attr和prop的区别&lt;/h1&gt;&lt;p&gt;在高
      
    
    </summary>
    
    
      <category term="JQuery" scheme="http://yoursite.com/tags/JQuery/"/>
    
      <category term="attr" scheme="http://yoursite.com/tags/attr/"/>
    
      <category term="prop" scheme="http://yoursite.com/tags/prop/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Modules</title>
    <link href="http://yoursite.com/ES6-Modules/"/>
    <id>http://yoursite.com/ES6-Modules/</id>
    <published>2017-02-11T10:45:12.000Z</published>
    <updated>2018-05-02T09:36:41.644Z</updated>
    
    <content type="html"><![CDATA[<p>ES6正式提出了内置的模块化语法，我们在浏览器端无需额外引入requirejs来进行模块化。</p><p><strong> ES6中的模块有以下特点： </strong></p><ol><li>模块自动运行在严格模式下</li><li>在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在；</li><li>模块顶级作用域的 this 值为 undefined</li><li>对于需要让模块外部代码访问的内容，模块必须导出它们</li></ol><h1 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h1><p>使用 <strong> export </strong> 关键字将任意变量、函数或者类公开给其他模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"cz"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出对象，即导出引用</span></span><br><span class="line"><span class="keyword">export</span> &#123;multiply&#125;</span><br></pre></td></tr></table></figure></p><h1 id="重命名模块"><a href="#重命名模块" class="headerlink" title="重命名模块"></a>重命名模块</h1><p>重命名想导出的变量、函数或类的名称<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;sum <span class="keyword">as</span> add&#125;</span><br></pre></td></tr></table></figure></p><p>这里将本地的sum函数重命名为add导出，因此在使用此模块的时候必须使用add这个名称。</p><h1 id="导出默认值"><a href="#导出默认值" class="headerlink" title="导出默认值"></a>导出默认值</h1><p>模块的默认值是使用 <strong> default 关键字 </strong> 所指定的单个变量、函数或类，而你在每个模块中 <strong> 只能设置一个默认导出。 </strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>function(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此模块将一个函数作为默认值进行了导出， default 关键字标明了这是一个默认导出。此函数并不需要有名称，因为它就代表这个模块自身。对比最前面使用export导出的函数，并不是匿名函数而是必须有一个名称用于加载模块的时候使用，但是默认导出则无需一个名字，因为模块名就代表了这个导出值。</p><p>也可以使用重命名语法来导出默认值。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> &#123; sum as<span class="built_in"> default </span>&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h1><p>在模块中使用<strong> import </strong>关键字来导入其他模块。<br>import 语句有两个部分，一是需要导入的标识符，二是需导入的标识符的来源模块。此处是导入语句的基本形式：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identifier1,identifier2 &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure></p><ul><li>大括号中指定了从给定模块导入的标识符</li><li>from指明了需要导入的模块。模块由一个表示模块路径的字符串来指定。</li></ul><p>当从模块导入了一个绑定时，你不能在当前文件中再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的 import 语句之前使用此标识符，更不能修改它的值。</p><h1 id="导入单个绑定"><a href="#导入单个绑定" class="headerlink" title="导入单个绑定"></a>导入单个绑定</h1><p>如果一个模块只导出了一个函数（或变量或类），或者导出了多个接口但是只选择导入其中的一个，那么就可以写成下面单个导入的模式：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure><h1 id="完全导入一个模块"><a href="#完全导入一个模块" class="headerlink" title="完全导入一个模块"></a>完全导入一个模块</h1><p>还有一种情况，就是将整个模块当做单一对象导入，该模块的所有导出都会作为对象的属性存在：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import * as <span class="built_in">example</span> from './<span class="built_in">example</span>.js'</span><br><span class="line"><span class="built_in">example</span>.<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">example</span>.multiply(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>在此代码中， example.js 中所有导出的绑定都被加载到一个名为 example 的对象中，具名导出（ sum() 函数、 multiple() 函数）都成为 example 的可用属性。<br>这种导入格式被称为<strong> 命名空间导入 </strong>，这是因为该 example 对象并不存在于 example.js 文件中，而是作为一个命名空间对象被创建使用，其中包含了 example.js 的所有导出成员。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然而要记住，无论你对同一个模块使用了多少次 <span class="keyword">import</span> 语句，该模块都只会被执行一次。</span><br></pre></td></tr></table></figure></p><p>在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 import 所引用.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">multiply</span> &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; magicNumber &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure><p>尽管此处的模块使用了三个 import 语句，但 example.js 只会被执行一次。若同一个应用中的其他模块打算从 example.js 导入绑定，则那些模块都会使用这段代码中所用的同一个模块实例。</p><h1 id="重命名导入"><a href="#重命名导入" class="headerlink" title="重命名导入"></a>重命名导入</h1><p>与导出相同，我们同样可以重命名导入的绑定：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum <span class="keyword">as</span> add&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure></p><h1 id="导入默认值"><a href="#导入默认值" class="headerlink" title="导入默认值"></a>导入默认值</h1><p>如果一个模块导出了默认值，那么可以这样导入默认值：</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure><p>这个导入语句从 example.js 模块导入了其默认值。注意此处并未使用花括号，与之前在非默认的导入中看到的不同。本地名称 sum 被用于代表目标模块所默认导出的函数，因此无需使用花括号。</p><p>如果一个模块既导出了默认值、又导出了一个或更多非默认的绑定的模块：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> let color = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>function(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以像下面这样使用一条import语句来导入它的所有导出绑定：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sum,&#123;<span class="built_in">color</span>&#125; from <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure></p><p>逗号将默认的本地名称与非默认的名称分隔开，后者仍旧被花括号所包裹。<br>要记住在 import 语句中<strong> 默认名称必须位于非默认名称之前。 </strong></p><h1 id="导入的再导出"><a href="#导入的再导出" class="headerlink" title="导入的再导出"></a>导入的再导出</h1><p>有时想在当前的模块中将已导入的内容再导出去，可以像下面这样写：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">export</span> &#123;sum&#125;</span><br></pre></td></tr></table></figure></p><p>但是有一种更简洁的方法：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br></pre></td></tr></table></figure><p>同样可以重命名：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> &#123; sum as <span class="builtin-name">add</span> &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure></p><p>也可以使用完全导出：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> * <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure></p><h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><p>export 与 import 都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部，而不能使用在if等代码块内部。原因之一是模块语法需要让 JS 能静态判断需要导出什么，正因为此，你只能在模块的顶级作用域使用 export与import。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES6正式提出了内置的模块化语法，我们在浏览器端无需额外引入requirejs来进行模块化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; ES6中的模块有以下特点： &lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块自动运行在严格模式下&lt;/li&gt;
&lt;li&gt;在模块的顶级作用域创建的变量，
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Array扩展</title>
    <link href="http://yoursite.com/es6%E6%96%B0%E5%A2%9Earray/"/>
    <id>http://yoursite.com/es6新增array/</id>
    <published>2017-02-10T13:16:21.000Z</published>
    <updated>2018-05-02T09:36:41.837Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em> find : </em></strong><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">234</span>,<span class="string">'sdf'</span>,<span class="number">-2</span>];</span><br><span class="line">arr.<span class="built_in">find</span>(<span class="function"><span class="keyword">function</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;=<span class="number">2</span>;</span><br><span class="line">&#125;)//结果：<span class="number">1</span>，返回第一个符合条件的x值</span><br><span class="line">arr.<span class="built_in">find</span>(<span class="function"><span class="keyword">function</span><span class="params">(x,i,arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">2</span>)&#123;console.<span class="built_in">log</span>(x,i,arr)&#125;</span><br><span class="line">&#125;)//结果：<span class="number">1</span> <span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="string">"sdf"</span>, <span class="number">-2</span>]，<span class="number">-2</span> <span class="number">4</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="string">"sdf"</span>, <span class="number">-2</span>]</span><br></pre></td></tr></table></figure></p><p>find的参数为回调函数，回调函数可以接收3个参数，值x、索引i、数组arr，回调函数默认返回值x。<br><strong><em> findIndex :</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">234</span>,<span class="string">'sdf'</span>,<span class="number">-2</span>];</span><br><span class="line">arr.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;=<span class="number">2</span>;</span><br><span class="line">&#125;)<span class="comment">//结果：0，返回第一个符合条件的x值的索引</span></span><br><span class="line">arr.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">x,i,arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">2</span>)&#123;<span class="built_in">console</span>.log(x,i,arr)&#125;</span><br><span class="line">&#125;)<span class="comment">//结果：1 0 [1, 2, 234, "sdf", -2]，-2 4 [1, 2, 234, "sdf", -2]</span></span><br></pre></td></tr></table></figure></p><p>findIndex和find差不多，不过默认返回的是索引。</p><p><strong><em> includes :</em></strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">234</span>,'sdf',<span class="number">-2</span>];</span><br><span class="line">arr.includes(<span class="number">2</span>);<span class="comment">// 结果true，返回布尔值</span></span><br><span class="line">arr.includes(<span class="number">20</span>);<span class="comment">// 结果：false，返回布尔值</span></span><br><span class="line">arr.includes(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">//结果：false，返回布尔值</span></span><br></pre></td></tr></table></figure></p><p>includes函数与string的includes一样，接收2参数，查询的项以及查询起始位置。</p><p><strong><em> keys :</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">234</span>,<span class="string">'sdf'</span>,<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> arr.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;<span class="comment">//结果：0,1,2,3,4  遍历了数组arr的索引</span></span><br></pre></td></tr></table></figure></p><p>keys，对数组索引的遍历</p><p><strong><em> values :</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">234</span>,<span class="string">'sdf'</span>,<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> arr.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;<span class="comment">//结果：1,2,234,sdf,-2 遍历了数组arr的值</span></span><br></pre></td></tr></table></figure></p><p>values，对数组项的遍历</p><p><strong><em> entries :</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="string">'w'</span>,<span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> arr.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;<span class="comment">//结果：[0,w],[1,b]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [i,v] <span class="keyword">of</span> arr.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i,v)</span><br><span class="line">&#125;<span class="comment">//结果：0 w,1 b</span></span><br></pre></td></tr></table></figure></p><p>entries，对数组键值对的遍历。</p><p><strong><em> fill :</em></strong><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[<span class="string">'w'</span>,<span class="string">'b'</span>];</span><br><span class="line">arr.fill(<span class="string">'i'</span>)//结果：[<span class="string">'i'</span>,<span class="string">'i'</span>]，改变原数组</span><br><span class="line">arr.fill(<span class="string">'o'</span>,<span class="number">1</span>)//结果：[<span class="string">'i'</span>,<span class="string">'o'</span>]改变原数组,第二个参数表示填充起始位置</span><br><span class="line">new <span class="symbol">Array</span>(<span class="number">3</span>).fill(<span class="string">'k'</span>).fill(<span class="string">'r'</span>,<span class="number">1</span>,<span class="number">2</span>)//结果：[<span class="string">'k'</span>,<span class="string">'r'</span>,<span class="string">'k'</span>]，第三个数组表示填充的结束位置</span><br></pre></td></tr></table></figure></p><p>fill方法改变原数组，当第三个参数大于数组长度时候，以最后一位为结束位置。</p><p><strong><em> Array.of() :</em></strong><br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="string">'w'</span>,<span class="string">'i'</span>,<span class="string">'r'</span>)//[<span class="string">"w"</span>, <span class="string">"i"</span>, <span class="string">"r"</span>]返回数组</span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>([<span class="string">'w'</span>,<span class="string">'o'</span>])//[[<span class="string">'w'</span>,<span class="string">'o'</span>]]返回嵌套数组</span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(undefined)//[undefined]依然返回数组</span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>()//[]返回一个空数组</span><br></pre></td></tr></table></figure></p><p>Array.of()方法永远返回一个数组，参数不分类型，只分数量，数量为0返回空数组。</p><p><strong><em> copyWithin :</em></strong><br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"w"</span>, <span class="string">"i"</span>, <span class="string">"r"</span>]<span class="string">.copyWithin</span><span class="params">(0)</span><span class="string">//</span>此时数组不变</span><br><span class="line">[<span class="string">"w"</span>, <span class="string">"i"</span>, <span class="string">"r"</span>]<span class="string">.copyWithin</span><span class="params">(1)</span><span class="string">//</span>[<span class="string">"w"</span>, <span class="string">"w"</span>, <span class="string">"i"</span>],数组从位置1开始被原数组覆盖，只有1之前的项0保持不变</span><br><span class="line">[<span class="string">"w"</span>, <span class="string">"i"</span>, <span class="string">"r"</span>,<span class="string">"b"</span>]<span class="string">.copyWithin</span><span class="params">(1,2)</span><span class="string">//</span>[<span class="string">"w"</span>, <span class="string">"r"</span>, <span class="string">"b"</span>, <span class="string">"b"</span>],索引2到最后的r,b两项分别替换到原数组1开始的各项，当数量不够，变终止</span><br><span class="line">[<span class="string">"w"</span>, <span class="string">"i"</span>, <span class="string">"r"</span>,'b']<span class="string">.copyWithin</span><span class="params">(1,2,3)</span><span class="string">//</span>[<span class="string">"w"</span>, <span class="string">"r"</span>, <span class="string">"r"</span>, <span class="string">"b"</span>]，强第1项的i替换为第2项的r</span><br></pre></td></tr></table></figure></p><p>copyWithin方法接收三个参数，被替换数据的开始处、替换块的开始处、替换块的结束处(不包括);copyWithin(s,m,n).</p><p><strong><em> Array.from() :</em></strong><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123;<span class="string">'0'</span>:<span class="string">'w'</span>,<span class="string">'1'</span>:<span class="string">'b'</span>,length:<span class="number">2</span>&#125;)<span class="regexp">//</span>[<span class="string">"w"</span>, <span class="string">"b"</span>],返回数组的长度取决于对象中的length，故此项必须有！</span><br><span class="line">Array.from(&#123;<span class="string">'0'</span>:<span class="string">'w'</span>,<span class="string">'1'</span>:<span class="string">'b'</span>,length:<span class="number">4</span>&#125;)<span class="regexp">//</span>[<span class="string">"w"</span>, <span class="string">"b"</span>, undefined, undefined],数组后<span class="number">2</span>项没有属性去赋值，故undefined</span><br><span class="line">Array.from(&#123;<span class="string">'0'</span>:<span class="string">'w'</span>,<span class="string">'1'</span>:<span class="string">'b'</span>,length:<span class="number">1</span>&#125;)<span class="regexp">//</span>[<span class="string">"w"</span>],length小于key的数目，按序添加数组</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span></span><br><span class="line">let divs=document.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line">Array.from(divs)<span class="regexp">//</span>返回div元素数组</span><br><span class="line">Array.from(<span class="string">'wbiokr'</span>)<span class="regexp">//</span>[<span class="string">"w"</span>, <span class="string">"b"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"k"</span>, <span class="string">"r"</span>]</span><br><span class="line">Array.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="keyword">function</span>(x)&#123;</span><br><span class="line">        return x+<span class="number">1</span>&#125;)<span class="regexp">//</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],第二个参数为回调函数</span><br></pre></td></tr></table></figure></p><p>Array.from可以把带有lenght属性类似数组的对象转换为数组，也可以把字符串等可以遍历的对象转换为数组，它接收2个参数，转换对象与回调函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt; find : &lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS规范</title>
    <link href="http://yoursite.com/CommonJS%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/CommonJS规范/</id>
    <published>2017-01-28T08:36:31.000Z</published>
    <updated>2018-05-02T09:36:41.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h1><p>在每个模块内部，module变量代表当前模块。它的exports属性是对外的接口，将模块的接口暴露出去。其他文件加载该模块，实际上就是读取module.exports变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><h1 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h1><p>require方法用于加载模块，后缀名默认为.js</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var app</span> = require(<span class="string">'./app.js'</span>);</span><br></pre></td></tr></table></figure><p><strong> 模块加载的顺序，按照其在代码中出现的顺序 </strong><br>根据参数的不同格式，require命令去不同路径寻找模块文件。<br>1) 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。<br>2) 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件<br>3) 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（node核心模块，或者通过全局安装或局部安装在node_modules目录中的模块）</p><h1 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h1><p>一般都会有一个主文件（入口文件），在index.html中加载这个入口文件，然后在这个入口文件中加载其他文件。<br><strong> 可以通过在package.json中配置main字段来指定入口文件。 </strong></p><h1 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h1><p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。</p><h1 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h1><p>CommonJS模块的加载机制是，<strong> 输入的是被输出的值的拷贝。  </strong> 也就是说， <strong> 一旦输出一个值，模块内部的变化就影响不到这个值。 </strong></p><h1 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h1><ol><li><p>CommonJs规范的出发点：JS没有模块系统、标准库较少、缺乏包管理工具；为了让JS可以在任何地方运行，以达到Java、C#、PHP这些后台语言具备开发大型应用的能力；</p></li><li><p>在CommonJs规范中：</p><p> 一个文件就是一个模块，拥有单独的作用域；</p><p> 普通方式定义的变量、函数、对象都属于该模块内；</p><p> 通过require来加载模块；</p><p> 通过exports和modul.exports来暴露模块中的内容；</p></li><li><p>所有代码都运行在模块作用域，不会污染全局作用域；模块可以多次加载，但只会在第一次加载的时候运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；模块的加载顺序，按照代码的出现顺序是同步加载的;</p></li><li><p><strong>dirname代表当前模块文件所在的文件夹路径，</strong>filename代表当前模块文件所在的文件夹路径+文件名;</p></li><li><p>require（同步加载）基本功能：读取并执行一个JS文件，然后返回该模块的exports对象，如果没有发现指定模块会报错;</p></li><li><p>模块内的exports：为了方便，node为每个模块提供一个exports变量，其指向module.exports，相当于在模块头部加了这句话：var exports = module.exports，在对外输出时，可以给exports对象添加方法，PS：不能直接赋值（因为这样就切断了exports和module.exports的联系）;</p></li><li><p>npm root -g：查看npm全局包安装位置，建议在nvm目录下新建npm\node_modules目录，然后设置npm的全局包安装位置：npm config set prefix “”，然后将该路径添加到环境变量中;</p></li><li><p>npm init -y：初始化一个package.json文件，加上-y就会默认生成该文件，无需一步一步填写；npm docs 包名：查看包的文档；npm install：安装package.json中dependencies属性中所有依赖的包</p></li><li><p>由于npm的服务器是国外的，所以如果你没有和谐工具是下载不了的，这里推荐使用淘宝NPM镜像：<a href="http://npm.taobao.org/，与官方NPM的同步频率目前为10分钟一次；安装命令：npm" target="_blank" rel="noopener">http://npm.taobao.org/，与官方NPM的同步频率目前为10分钟一次；安装命令：npm</a> install -g cnpm –registry=<a href="https://registry.npm.taobao.org，安装包：cnpm" target="_blank" rel="noopener">https://registry.npm.taobao.org，安装包：cnpm</a> install 包名（其它命令基本一致）;</p></li><li><p>如果你不想下载cnpm，npm还提供了一个镜像源管理工具：npm install -g nrm，通过：nrm ls，查看镜像源列表 ，通过：npm use 镜像源，来切换;</p></li><li><p>NPM的模块加载机制：</p><p>  如果require的是绝对路径文件，查找不会去遍历每个node_modules目录，其速度最快</p></li></ol><p>　　1）.从module.paths数组中（由当前执行文件目录到磁盘根目录）取出第一个目录作为查找基准</p><p>　　2）.直接从目录中查找该文件，如果存在则结束查找，如果不存在则进行下一条查找</p><p>　　3）.尝试添加.js、.json、.node后缀之后查找，如果存在文件则结束查找，如果不存在则进行下一条查找</p><p>　　4）.尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得Main参数指定的文件</p><p>　　5）.尝试查找该文件，如果存在则结束查找，如果不存在则进行第3条查找</p><p>　　6）.如果继续失败，则取出module.paths数组中的下一目录作为基准查找，循环第1-5个步骤</p><p>　　7）.如果继续失败，循环第1-6个步骤，直到module.paths中的最后一个值</p><p>　　8）.如果继续失败，则抛出异常</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义模块&quot;&gt;&lt;a href=&quot;#定义模块&quot; class=&quot;headerlink&quot; title=&quot;定义模块&quot;&gt;&lt;/a&gt;定义模块&lt;/h1&gt;&lt;p&gt;在每个模块内部，module变量代表当前模块。它的exports属性是对外的接口，将模块的接口暴露出去。其他文件加载该模块，
      
    
    </summary>
    
    
      <category term="CommonJS" scheme="http://yoursite.com/tags/CommonJS/"/>
    
      <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://yoursite.com/Ajax/"/>
    <id>http://yoursite.com/Ajax/</id>
    <published>2017-01-20T09:30:46.000Z</published>
    <updated>2018-05-02T09:36:36.257Z</updated>
    
    <content type="html"><![CDATA[<p>ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。</p><h2 id="ajax原理和XmlHttpRequest对象"><a href="#ajax原理和XmlHttpRequest对象" class="headerlink" title="ajax原理和XmlHttpRequest对象"></a>ajax原理和XmlHttpRequest对象</h2><p><strong> Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 </strong></p><p>XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</p><p>首先，我们先来看看XMLHttpRequest这个对象的属性。</p><p>　　它的属性有：</p><p>　　onreadystatechange  每次状态改变所触发事件的事件处理程序。</p><p>　　responseText     从服务器进程返回数据的字符串形式。</p><p>　　responseXML    从服务器进程返回的DOM兼容的文档数据对象。</p><p>　　status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</p><p>　　status Text       伴随状态码的字符串信息</p><p>　　readyState       对象状态值</p><p>　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）</p><p>　　　　1 (初始化) 对象已建立，尚未调用send方法</p><p>　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知</p><p>　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，</p><p>　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</p><p>　　但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//创建传输对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(window.XMLHttpRequest)&#123;</span><br><span class="line">        <span class="keyword">return</span> new XMLHrrpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//obj &#123;name:huhu,age:<span class="number">18</span>&#125;  =&gt; <span class="string">"name=huhu&amp;age=18"</span></span><br><span class="line">//格式化参数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">params</span><span class="params">(obj)</span></span> &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    <span class="keyword">for</span>(var i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        var str = i + <span class="string">"="</span> + obj[i];</span><br><span class="line">        arr.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push((<span class="string">"v="</span> + Math.<span class="built_in">random</span>()).replace(<span class="string">"."</span>, <span class="string">""</span>));</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">"&amp;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span><span class="params">(option)</span></span>&#123;</span><br><span class="line">    option = option || &#123;&#125;;</span><br><span class="line">    option.url = option.url || <span class="string">''</span>;</span><br><span class="line">    option.<span class="built_in">type</span> = option.<span class="built_in">type</span>.toUpperCase() || <span class="string">'GET'</span>;</span><br><span class="line">    option.data = option.data || <span class="string">''</span>;</span><br><span class="line">    option.async = option.async || <span class="literal">true</span>;</span><br><span class="line">    option.success = option.success || <span class="function"><span class="keyword">function</span> <span class="params">(data)</span></span> &#123;&#125;;</span><br><span class="line">    option.<span class="built_in">error</span> = option.errro || <span class="function"><span class="keyword">function</span> <span class="params">(data)</span></span> &#123;&#125;;</span><br><span class="line">    // 第一步 创建对象</span><br><span class="line">    var xhr = createXHR();</span><br><span class="line">    //连接 和 发送 - 第二步</span><br><span class="line">    <span class="keyword">if</span> (option.<span class="built_in">type</span> == <span class="string">"GET"</span>) &#123;</span><br><span class="line">        xhr.<span class="built_in">open</span>(<span class="string">"GET"</span>, option.url + <span class="string">"?"</span> + params(option.data), option.async);</span><br><span class="line">        xhr.send(null);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option.<span class="built_in">type</span> == <span class="string">"POST"</span>) &#123;</span><br><span class="line">        xhr.<span class="built_in">open</span>(<span class="string">"POST"</span>, option.url, option.async);</span><br><span class="line">        //设置表单提交时的内容类型</span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        xhr.send(params(option.data));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">'类型有误'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (XHR.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">            var <span class="built_in">status</span> = xhr.<span class="built_in">status</span>;</span><br><span class="line">            <span class="keyword">if</span> (XHR.<span class="built_in">status</span> &gt;= <span class="number">200</span> &amp;&amp; XHR.<span class="built_in">status</span> &lt; <span class="number">300</span> || XHR.<span class="built_in">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">                switch (obj.responseType) &#123;</span><br><span class="line">                    case <span class="string">'document'</span>:</span><br><span class="line">                        obj.success(XHR.responseXML);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    case <span class="string">'json'</span>:</span><br><span class="line">                        obj.success(XHR.response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    default:</span><br><span class="line">                        obj.success(XHR.responseText);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                option.<span class="built_in">error</span>(<span class="built_in">status</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*  使用</span><br><span class="line">    ajax(&#123;</span><br><span class="line">        <span class="built_in">type</span>:请求的方式  get/post 如果省略 默认是get,</span><br><span class="line">        url:不能省略 必须参数 服务器地址,</span><br><span class="line">        data:&#123;&#125; 参数 如果没有参数省略即可,</span><br><span class="line">        async: ture/<span class="literal">false</span> 是否是异步 默认不写就是异步,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;&#125; 请求成功的回调函数 data表示请求回来的数据,</span><br><span class="line">        <span class="built_in">error</span>:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;&#125; 请求失败的回调函数,</span><br><span class="line">        responseType:document(请求xml数据)    json(请求json数据) text  如果省略默认返回text</span><br><span class="line">    &#125;);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>还有其他封装方法 不一一列出了~</p><h2 id="Ajax的缺点"><a href="#Ajax的缺点" class="headerlink" title="Ajax的缺点"></a>Ajax的缺点</h2><p>下面所阐述的ajax的缺陷都是它先天所产生的。</p><p>   　1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）</p><p>但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。</p><p>2、安全问题</p><p>技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。<br> 3、对搜索引擎的支持比较弱。</p><p> 4、破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。</p><p> 5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。</p><p> 6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。&lt;/p&gt;
&lt;h2 id=&quot;ajax原理和XmlHttpRequest对象&quot;&gt;&lt;a href=&quot;#ajax
      
    
    </summary>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>class 类--初识</title>
    <link href="http://yoursite.com/Class-%E7%B1%BB-%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/Class-类-初识/</id>
    <published>2017-01-17T07:37:03.000Z</published>
    <updated>2018-05-21T08:10:38.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><p>定义一个类的一种方法是使用一个类声明。要声明一个类，你可以使用带有class关键字的类名</p><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Remou</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p><blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Foo</span>(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p><blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let <span class="type">Foo</span> = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</p><h1 id="类的表达式"><a href="#类的表达式" class="headerlink" title="类的表达式"></a>类的表达式</h1><p>一个<strong> 类表达式 </strong>是定义一个类的另一种方式。类表达式可以是被命名的或匿名的。赋予一个命名类表达式的名称是类的主体的本地名称。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名的类</span></span><br><span class="line"><span class="keyword">let</span> Rou = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名的类</span></span><br><span class="line"><span class="keyword">let</span> Rou = <span class="class"><span class="keyword">class</span> <span class="title">Remou</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong> 注意:  </strong> 类<strong>表达式</strong>也同样受到<strong>类声明</strong>中提到的提升问题的困扰。</p><hr><h1 id="类的方法和定义"><a href="#类的方法和定义" class="headerlink" title="类的方法和定义"></a>类的方法和定义</h1><p><br></p><blockquote><p>一个类的类体是一对花括号 {} 中的部分。这是你定义类成员的位置，如方法或构造函数。</p></blockquote><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><blockquote><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p></blockquote><blockquote><p>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p></blockquote><p>类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter和setter都在严格模式下执行。</p><h2 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h2><p><span style="display:inline-block;background-color:#999">constructor</span>方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有<span style="display:inline-block;background-color:#999">constructor</span>方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。</p><p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p><hr><p>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo()</span><br><span class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure></p><h1 id="类的实例化对象"><a href="#类的实例化对象" class="headerlink" title="类的实例化对象"></a>类的实例化对象</h1><p>生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> point = Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = new Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">point.toString() <span class="comment">// (2, 3)</span></span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。</p><p>与 ES5 一样，类的所有实例共享一个原型对象。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.__proto__ === p2.__proto__</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。<br><br>这也意味着，可以通过实例的__proto__属性为“类”添加方法。</p><p>__proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="keyword">function</span> </span>() &#123; <span class="keyword">return</span> <span class="string">'Oops'</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() <span class="comment">// "Oops"</span></span><br><span class="line">p2.printName() <span class="comment">// "Oops"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">p3.printName() <span class="comment">// "Oops"</span></span><br></pre></td></tr></table></figure></p><p>上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的<strong>proto</strong>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p><h1 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h1><p>与函数一样，类也可以使用表达式的形式定义。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inst = <span class="function"><span class="keyword">new</span> <span class="title">MyClass</span>();</span></span><br><span class="line"><span class="function"><span class="title">inst</span>.<span class="title">getClassName</span>() <span class="comment">// Me</span></span></span><br><span class="line"><span class="function"><span class="title">Me</span>.<span class="title">name</span> <span class="comment">// ReferenceError: Me is not defined</span></span></span><br></pre></td></tr></table></figure></p><p>上面代码表示，Me只在 Class 内部有定义。<br><br>如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p><p><code>const MyClass = class { /* ... */ };</code><br>采用 Class 表达式，可以写出立即执行的 Class。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure></p><h2 id="上面代码中，person是一个立即执行的类的实例。"><a href="#上面代码中，person是一个立即执行的类的实例。" class="headerlink" title="上面代码中，person是一个立即执行的类的实例。"></a>上面代码中，person是一个立即执行的类的实例。</h2><h1 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h1><p>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别。</p><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  _bar(baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。<br><br>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p><blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(<span class="keyword">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(baz)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。<br></p><p>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</p><blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">'snaf'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p><h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> &#123;</span></span><br><span class="line">  printName(name = <span class="string">'there'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">print</span>(`<span class="javascript">Hello $&#123;name&#125;</span>`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = <span class="keyword">new</span> Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="regexp">//</span> TypeError: Cannot read property <span class="string">'print'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。<br><br>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。</p><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>另一种解决方法是使用箭头函数。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">'there'</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。(目前水平达不到先记录一下)</p><blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">selfish</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> WeakMap();</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">value</span> = Reflect.<span class="keyword">get</span>(target, key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">value</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(<span class="keyword">value</span>)) &#123;</span><br><span class="line">        cache.<span class="keyword">set</span>(<span class="keyword">value</span>, <span class="keyword">value</span>.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="keyword">get</span>(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> Proxy(target, handler);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</span><br></pre></td></tr></table></figure></blockquote><h1 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h1><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p><blockquote><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Point</span> &#123;&#125;</span><br><span class="line"><span class="keyword">Point</span>.name // <span class="string">"Point"</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="name属性总是返回紧跟在class关键字后面的类名。"><a href="#name属性总是返回紧跟在class关键字后面的类名。" class="headerlink" title="name属性总是返回紧跟在class关键字后面的类名。"></a>name属性总是返回紧跟在class关键字后面的类名。</h2><h1 id="Class-的取值函数（getter）和存值函数（setter）"><a href="#Class-的取值函数（getter）和存值函数（setter）" class="headerlink" title="Class 的取值函数（getter）和存值函数（setter）"></a>Class 的取值函数（getter）和存值函数（setter）</h1><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">prop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">prop</span>(<span class="params"><span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    console.log(<span class="string">'setter: '</span>+<span class="keyword">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// 'getter'</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。<br><br>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> html(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = Object.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, <span class="string">"html"</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="string">"get"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">"set"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与-ES5-完全一致。"><a href="#上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与-ES5-完全一致。" class="headerlink" title="上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。"></a>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。</h2><h1 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h1><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">classMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。<br></p><blockquote><p>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">baz</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    console.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  baz () &#123;</span><br><span class="line">    console.log(<span class="string">'world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></p></blockquote><p>上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。<br><br>父类的静态方法，可以被子类继承。</p><blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="symbol">'hell</span>o';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Bar</span>.classMethod() <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。<br><br>静态方法也是可以从super对象上调用的。</p><blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="symbol">'hell</span>o';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + ', too';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Bar</span>.classMethod() <span class="comment">// "hello, too"</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="Class-的静态属性和实例属性"><a href="#Class-的静态属性和实例属性" class="headerlink" title="Class 的静态属性和实例属性"></a>Class 的静态属性和实例属性</h1><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p><blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.<span class="keyword">prop</span> = 1;</span><br><span class="line">Foo.<span class="keyword">prop</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></blockquote><p>上面的写法为Foo类定义了一个静态属性prop。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</p><blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都无效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  <span class="comment">// 写法一</span></span><br><span class="line"><span class="symbol">  prop:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写法二</span></span><br><span class="line">  <span class="keyword">static</span> <span class="string">prop:</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h1><p>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p><blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>(name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span><span class="type"></span>.target !== undefined) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">'必须使用 new 命令生成实例'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span></span>(name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span><span class="type"></span>.target === Person) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">'必须使用 new 命令生成实例'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">'张三'</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'张三'</span>);  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码确保构造函数只能通过new命令调用。</p><p>Class 内部调用new.target，返回当前 Class。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></blockquote><p>需要注意的是，子类继承父类时，new.target会返回子类。</p><blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    console.log(<span class="keyword">new</span>.target === <span class="type">Rectangle</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="type">Square</span>(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，new.target会返回子类。</p><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p><blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === <span class="type">Shape</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>('本类不能实例化');</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  constructor(length, width) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="type">Shape</span>();  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="type">Rectangle</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，Shape类不能被实例化，只能用于继承。</p><p>注意，在函数外部，使用new.target会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类的声明&quot;&gt;&lt;a href=&quot;#类的声明&quot; class=&quot;headerlink&quot; title=&quot;类的声明&quot;&gt;&lt;/a&gt;类的声明&lt;/h1&gt;&lt;p&gt;定义一个类的一种方法是使用一个类声明。要声明一个类，你可以使用带有class关键字的类名&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Array方法</title>
    <link href="http://yoursite.com/Array%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/Array方法/</id>
    <published>2017-01-12T12:06:19.000Z</published>
    <updated>2018-05-02T09:36:38.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h1><p>join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">join</span>()); <span class="comment">// 1,2,3</span></span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">join</span>(<span class="string">"-"</span>)); <span class="comment">// 1-2-3</span></span><br><span class="line">console.<span class="built_in">log</span>(arr); <span class="comment">// [1, 2, 3]（原数组不变）</span></span><br></pre></td></tr></table></figure></p><p>通过join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重复后的字符串，函数如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatString</span>(<span class="params">str, n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).join(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(repeatString(<span class="string">"abc"</span>, <span class="number">3</span>)); <span class="comment">// abcabcabc</span></span><br><span class="line"><span class="built_in">console</span>.log(repeatString(<span class="string">"Hi"</span>, <span class="number">5</span>)); <span class="comment">// HiHiHiHiHi</span></span><br></pre></td></tr></table></figure></p><h1 id="push-和pop"><a href="#push-和pop" class="headerlink" title="push()和pop()"></a>push()和pop()</h1><p>push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。<br>pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="built_in">var</span> count = arr.<span class="built_in">push</span>(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(count); // <span class="number">5</span></span><br><span class="line">console.<span class="built_in">log</span>(arr); // [<span class="string">"Lily"</span>, <span class="string">"lucy"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>, <span class="string">"Sean"</span>]</span><br><span class="line"><span class="built_in">var</span> item = arr.<span class="built_in">pop</span>();</span><br><span class="line">console.<span class="built_in">log</span>(item); // Sean</span><br><span class="line">console.<span class="built_in">log</span>(arr); // [<span class="string">"Lily"</span>, <span class="string">"lucy"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>]</span><br></pre></td></tr></table></figure></p><h1 id="shift-和-unshift"><a href="#shift-和-unshift" class="headerlink" title="shift() 和 unshift()"></a>shift() 和 unshift()</h1><p>shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。<br>unshift:将参数添加到原数组开头，并返回数组的长度 。</p><p>这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"Lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr.unshift(<span class="string">"Jack"</span>,<span class="string">"Sean"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="regexp">// 5</span></span><br><span class="line"><span class="regexp">console.log(arr); //</span>[<span class="string">"Jack"</span>, <span class="string">"Sean"</span>, <span class="string">"Lily"</span>, <span class="string">"lucy"</span>, <span class="string">"Tom"</span>]</span><br><span class="line"><span class="keyword">var</span> item = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="regexp">// Jack</span></span><br><span class="line"><span class="regexp">console.log(arr); //</span> [<span class="string">"Sean"</span>, <span class="string">"Lily"</span>, <span class="string">"lucy"</span>, <span class="string">"Tom"</span>]</span><br></pre></td></tr></table></figure></p><h1 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h1><p>sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。</p><p>在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> arr1 = [<span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>];</span><br><span class="line">console.<span class="built_in">log</span>(arr1.<span class="built_in">sort</span>()); // [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line">arr2 = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line">console.<span class="built_in">log</span>(arr2.<span class="built_in">sort</span>()); // [<span class="number">13</span>, <span class="number">24</span>, <span class="number">3</span>, <span class="number">51</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr2); // [<span class="number">13</span>, <span class="number">24</span>, <span class="number">3</span>, <span class="number">51</span>](元数组被改变)</span><br></pre></td></tr></table></figure></p><p>为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr<span class="number">2</span> = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line">console.log(arr<span class="number">2</span>.sort(compare)); <span class="comment">// [3, 13, 24, 51]</span></span><br></pre></td></tr></table></figure></p><p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr<span class="number">2</span> = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line">console.log(arr<span class="number">2</span>.sort(compare)); <span class="comment">// [51, 24, 13, 3]</span></span><br></pre></td></tr></table></figure></p><h1 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h1><p>reverse()：反转数组项的顺序。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [13, 24, 51, 3];</span><br><span class="line">console.log(arr.reverse()); //[3, 51, 24, 13]</span><br><span class="line">console.log(arr); //[<span class="string">3, 51, 24, 13</span>](<span class="link">原数组改变</span>)</span><br></pre></td></tr></table></figure></p><h1 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h1><p>concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,3,5,7];</span><br><span class="line">var arrCopy = arr.concat(9,[11,13]);</span><br><span class="line">console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]</span><br><span class="line">console.log(arr); // [<span class="string">1, 3, 5, 7</span>](<span class="link">原数组未被修改</span>)</span><br></pre></td></tr></table></figure></p><p>从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arrCopy2 = arr.concat(<span class="comment">[9,<span class="comment">[11,13]</span>]</span>);</span><br><span class="line">console.log(arrCopy2); //<span class="comment">[1, 3, 5, 7, 9, Array<span class="comment">[2]</span>]</span></span><br><span class="line">console.log(arrCopy2<span class="comment">[5]</span>); //<span class="comment">[11, 13]</span></span><br></pre></td></tr></table></figure></p><p>上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。</p><h1 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h1><p>slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line">var arrCopy = arr.slice(<span class="number">1</span>);</span><br><span class="line">var arrCopy2 = arr.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">var arrCopy3 = arr.slice(<span class="number">1</span>,<span class="number">-2</span>);</span><br><span class="line">var arrCopy4 = arr.slice(<span class="number">-4</span>,<span class="number">-1</span>);</span><br><span class="line">console.log(arr); <span class="comment">//[1, 3, 5, 7, 9, 11](原数组没变)</span></span><br><span class="line">console.log(arrCopy); <span class="comment">//[3, 5, 7, 9, 11]</span></span><br><span class="line">console.log(arrCopy2); <span class="comment">//[3, 5, 7]</span></span><br><span class="line">console.log(arrCopy3); <span class="comment">//[3, 5, 7]</span></span><br><span class="line">console.log(arrCopy4); <span class="comment">//[5, 7, 9]</span></span><br></pre></td></tr></table></figure></p><p>arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。<br>arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。<br>arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。<br>arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。</p><h1 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h1><p>splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。</p><p>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。</p><p>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。<br>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。</p><p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line">var arrRemoved = arr.splice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">console.log(arr); <span class="comment">//[5, 7, 9, 11]</span></span><br><span class="line">console.log(arrRemoved); <span class="comment">//[1, 3]</span></span><br><span class="line">var arrRemoved2 = arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">console.log(arr); <span class="comment">// [5, 7, 4, 6, 9, 11]</span></span><br><span class="line">console.log(arrRemoved2); <span class="comment">// []</span></span><br><span class="line">var arrRemoved3 = arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">console.log(arr); <span class="comment">// [5, 2, 4, 4, 6, 9, 11]</span></span><br><span class="line">console.log(arrRemoved3); <span class="comment">//[7]</span></span><br></pre></td></tr></table></figure><h1 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf()和 lastIndexOf()"></a>indexOf()和 lastIndexOf()</h1><p>indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。<br>lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</p><p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">console.log(arr.indexOf(<span class="number">5</span>)); <span class="comment">//2</span></span><br><span class="line">console.log(arr.lastIndexOf(<span class="number">5</span>)); <span class="comment">//5</span></span><br><span class="line">console.log(arr.indexOf(<span class="number">5</span>,<span class="number">2</span>)); <span class="comment">//2</span></span><br><span class="line">console.log(arr.lastIndexOf(<span class="number">5</span>,<span class="number">4</span>)); <span class="comment">//2</span></span><br><span class="line">console.log(arr.indexOf(<span class="string">"5"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure></p><h1 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h1><p>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x, index, a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x + <span class="string">'|'</span> + index + <span class="string">'|'</span> + (a === arr));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// 1|0|true</span></span><br><span class="line"><span class="comment">// 2|1|true</span></span><br><span class="line"><span class="comment">// 3|2|true</span></span><br><span class="line"><span class="comment">// 4|3|true</span></span><br><span class="line"><span class="comment">// 5|4|true</span></span><br></pre></td></tr></table></figure></p><h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><p>map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p><p>下面代码利用map方法实现数组中每个数求平方。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item*item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></p><h1 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h1><p>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">var arr2 = arr.filter(function(x, index) &#123;</span><br><span class="line">return index % <span class="number">3</span> === <span class="number">0</span> || x &gt;= <span class="number">8</span>;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr2); <span class="comment">//[1, 4, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure></p><h1 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h1><p>every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h1 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h1><p>some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h1 id="reduce-和-reduceRight"><a href="#reduce-和-reduceRight" class="headerlink" title="reduce()和 reduceRight()"></a>reduce()和 reduceRight()</h1><p>这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p><p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</p><p>传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p><p>下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">values</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">sum</span> = <span class="built_in">values</span>.reduceRight(function(prev, cur, index, <span class="built_in">array</span>)&#123;</span><br><span class="line"><span class="built_in">return</span> prev + cur;</span><br><span class="line">&#125;,<span class="number">10</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">sum</span>); //<span class="number">25</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;join&quot;&gt;&lt;a href=&quot;#join&quot; class=&quot;headerlink&quot; title=&quot;join()&quot;&gt;&lt;/a&gt;join()&lt;/h1&gt;&lt;p&gt;join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为
      
    
    </summary>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
</feed>
