{"meta":{"title":"小小世界","subtitle":"web前端开发","description":"前端开发","author":"lyw","url":"writebugs.cn"},"pages":[{"title":"lyw","date":"2017-03-10T04:38:56.000Z","updated":"2018-05-26T05:16:05.907Z","comments":true,"path":"about/index.html","permalink":"writebugs.cn/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 javascript，熟悉使用 vue、react 等主流框架；有一定的代码洁癖。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：北京 关于学习正在往终身学习者前进… 近期学习方向：Python (人工智能) 关于座右铭The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好热爱运动，尤其喜爱羽毛球、阅读、电影（Top250）、旅行。 联系我Home: writebugs.cnEmail: 1094395447@qq.com.comGitHub: github.com/lywnodejs"},{"title":"tags","date":"2018-05-21T09:53:06.000Z","updated":"2018-05-21T09:55:58.043Z","comments":true,"path":"tags/index.html","permalink":"writebugs.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"avalon","slug":"avalon","date":"2018-10-27T16:00:00.000Z","updated":"2018-11-08T07:40:48.317Z","comments":true,"path":"avalon/","link":"","permalink":"writebugs.cn/avalon/","excerpt":"","text":"avalon2是一款基于虚拟DOM与属性劫持的 迷你、 易用、 高性能 的 前端MVVM框架， 拥有超优秀的兼容性, 支持移动开发, 后端渲染, WEB Component式组件开发, 无需编译, 开箱即用。 avalon avalon的所有操作都是围绕vm进行。 vm，亦即view model，视图模型。只要我将一个JS对象添加一个$id属性， 再放到avalon.define方法里面，就能得到一个vm。1234 var vm = avalon.define(&#123; $id: \"start\", name: \"test\"&#125;) 里面以$带头的属性或放到$skipArray，都转换为访问器属性，也就是其他语言的setter, getter。因此如果这个属性最初没有定义，那么它就不会转换为访问器属性，修改该属性，就不会刷新视图。 计算属性集中定义在$computed对象中。有多种形式。函数形式的只读计算属性123456789101112131415avalon.define(&#123; $id: 'test', firstName: '333', lastName: 'xxx', $computed: &#123; //fullName依赖于firstName与lastName fullName: function()&#123; return this.firstName+' '+this.lastName &#125;, //xxx只依赖于firstNaem xxx: function()&#123; return this.firstName+'!!' &#125; &#125;&#125;) 插值表达式 位于文本节点中的双重花括号,当然这个可以配置.此指令其中文本ms-text指令的简单形式.12345678910111213&lt;body ms-controller=\"test\"&gt; &lt;script&gt; avalon.define(&#123; $id: 'test', aaa: 'aaa', bbb: 'bbb' &#125;) &lt;/script&gt; &lt;p&gt;&#123;&#123;@aaa&#125;&#125;&#123;&#123;@bbb&#125;&#125; 这个性能差些&lt;/p&gt; &lt;p&gt;&#123;&#123;@aaa+@bbb&#125;&#125; 这个性能好些&lt;/p&gt; &lt;p&gt;&#123;&#123;@aaa+@bbb | uppercase&#125;&#125; 选择器必须放在表达值的后端&lt;/p&gt;&lt;/body&gt; skip绑定 让avalon的扫描引擎跳过某一部分区域, 方便能原样输出合理使用ms-skip能大大提高性能1234567891011&lt;body :controller=\"test\"&gt;&lt;script&gt;var vm = avalon.define(&#123; $id: \"test\", aaa: \"XXXX\" toggle: false&#125;)&lt;/script&gt;&lt;div ms-skip='true' &gt;&#123;&#123;@aaa&#125;&#125;&lt;/div&gt;&lt;div&gt;&#123;&#123;@aaa&#125;&#125;&lt;/div&gt;&lt;/body&gt; controller绑定 这个指令是用于圈定某个VM的作用域范围(换言之,这个元素的outerHTML会被扫描编译,所有ms-*及双花括号替换成vm中的内容),ms-controller的属性值只能是某个VM的$idms-controller的元素节点下面的其他节点也可以使用ms-controller每个VM的$id可以在页面上出现一次, 因此不要在ms-for内使用ms-controller.当我们在某个指令上用@aaa时,它会先从其最近的ms-controller元素上找, 找不到再往其更上方的ms-controller元素 important绑定 这个指令是用于圈定某个VM的作用域范围(换言之,这个元素的outerHTML会被扫描编译,所有ms-*及双花括号替换成vm中的内容),ms-important的属性值只能是某个VM的$idms-important的元素节点下面的其他节点也可以使用ms-controller或ms-important与ms-controller不一同的是,当某个属性在ms-important的VM找不到时,就不会所上寻找 不要在ms-for内使用ms-important.ms-important这特性有利协作开发,每个人的VM都不会影响其他人,并能大大提高性能ms-important只能用于ms-controller的元素里面12345678910&lt;div ms-important='aaa'&gt; &lt;div ms-controller='ccc'&gt; &lt;div ms-important='ddd'&gt; &lt;/div&gt; &lt;/div&gt; &lt;div ms-controller='bbb'&gt; &lt;/div&gt;&lt;/div&gt; 属性绑定 属性绑定用于为元素节点添加一组属性, 因此要求属性值为对象或数组形式. 数组最后也会合并成一个对象.然后取此对象的键名为属性名, 键值为属性值为元素添加属性如果键名如果为for, char这样的关键字,请务必在两边加上引号如果键名如果带横杠,请务必转换为驼峰风格或两边加上引号注意,不能在ms-attr中设置style属性1&lt;p ms-attr=\"&#123;style:'width:20px'&#125;\"&gt;这样写是错的,需要用ms-css指令!!&lt;/p&gt; 示例:123456789101112131415161718192021222324&lt;body ms-controller=\"test\"&gt; &lt;script&gt; avalon.define(&#123; $id: 'test', obj: &#123;title: '普通 ', algin: 'left'&#125;, active: &#123;title: '激活'&#125;, width: 111, height: 222, arr: [&#123;img: 'aaa'&#125;, &#123;img: 'bbb'&#125;, &#123;img: 'ccc'&#125;], path: '../aaa/image.jpg', toggle: false, array: [&#123;width: 1&#125;, &#123;height: 2&#125;] &#125;) &lt;/script&gt; &lt;span ms-attr=\"@obj\"&gt;直接引用对象&lt;/span&gt; &lt;img ms-attr=\"&#123;src: @path&#125;\" /&gt; &lt;ul&gt; &lt;li ms-for=\"el in @arr\"&gt;&lt;a ms-attr=\"&#123;href:'http://www.ccc.xxx/ddd/'+ el.img&#125;\"&gt;下载&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span :attr=\"&#123;width: @width, height: @height&#125;\"&gt;使用对象字面量&lt;/span&gt;&lt;br/&gt; &lt;span :attr=\"@array\"&gt;直接引用数组&lt;/span&gt;&lt;br/&gt; &lt;span :attr=\"[@obj, @toggle &amp;&amp; @active ]\" :click=\"@toggle = !@toggle\"&gt;选择性添加多余属性或重写已有属性&lt;/span&gt;&lt;/body&gt; 样式绑定 CSS绑定用于为元素节点添加一组样式, 因此要求属性值为对象或数组形式. 数组最后也会合并成一个对象.然后取此对象的键名为样式名, 键值为样式值为元素添加样式如果键名为表示长宽,字体大小这样的样式, 那么键值不需要加单位,会自动加上px如果键名如果为float,请务必在两边加上引号如果键名如果为font-size,请务必转换为驼峰风格或两边加上引号123456789101112131415161718&lt;body ms-controller=\"test\"&gt; &lt;script&gt; avalon.define(&#123; $id: 'test', obj: &#123;backgroundColor: '#3bb0d0',width:300, height:50, 'text-align': 'center'&#125;,//属性名带-,必须用引号括起 active: &#123;color: 'red'&#125;, width: 300, height: 60, toggle: true, array: [&#123;width:100&#125;,&#123;height:50&#125;,&#123;border: '1px solid #5cb85c'&#125;] &#125;) &lt;/script&gt; &lt;div ms-css=\"@obj\"&gt;直接引用对象&lt;/div&gt; &lt;div :css=\"&#123;width: @width, height: @height,background: 'pink'&#125;\"&gt;使用对象字面量&lt;/div&gt; &lt;div :css=\"@array\"&gt;直接引用数组&lt;/div&gt; &lt;div :css=\"[@obj, @toggle &amp;&amp; @active ]\" :click=\"@toggle = !@toggle\"&gt;选择性添加多余属性或重写已有属性&lt;/div&gt;&lt;/body&gt; 可见性绑定 这是通过修改元素的style.display值改变元素的可见性, 要求属性值对应一个布尔，如果不是布尔， avalon会自动转换值为布尔。1234567891011&lt;body :controller=\"test\"&gt;&lt;script&gt;var vm = avalon.define(&#123; $id: \"test\", aaa: \"这是被隐藏的内容\" toggle: false&#125;)&lt;/script&gt;&lt;p&gt;&lt;button type=\"button\" :click='@toggle = !@toggle'&gt;点我&lt;/span&gt;&lt;/p&gt;&lt;div :visible=\"@toggle\"&gt;&#123;&#123;@aaa&#125;&#125;&lt;/div&gt;&lt;/body&gt; 双工绑定 双工绑定是MVVM框架中最强大的指令.react推崇单向数据流,没有双工绑定, 那么需要rudex等额外的库来实现相同的功能.双工绑定只要用于表单元素上.或当一个div设置了contenteditable为true,也可以用ms-duplex指令.各个表单元素的用法123456789101112131415&lt;body ms-controller=\"test\"&gt; &lt;script&gt; avalon.define(&#123; $id: 'test', aaa: 'aaa', bbb: 'bbb', ccc: 'ccc' &#125;) &lt;/script&gt; &lt;input ms-duplex=\"@aaa\"/&gt;&#123;&#123;@aaa&#125;&#125; &lt;input ms-duplex=\"@bbb\" type=\"password\"/&gt;&#123;&#123;@bbb&#125;&#125; &lt;textarea ms-duplex=\"@ccc\" /&gt;&lt;/textarea&gt;&#123;&#123;@ccc&#125;&#125;&lt;/body&gt; 上面有三个控件,text, password, textarea它们都是属于输入型控件, 只要每为控件敲入一个字符, 后面的文本都会立即变化.那是因为它们默认是绑定oninput事件,如果想控件全部输入好,失去焦点时 才同步,那么可以使用change过滤器1&lt;input ms-duplex=\"@aaa | change\"/&gt;&#123;&#123;@aaa&#125;&#125; 如果你是做智能提示, 控件是绑定了一个AJAX请求与后端不断交互, 使用oninput事件会太频繁, 使用onchange事件会太迟钝,那么我们可以使用debounce过滤器1&lt;input ms-duplex=\"@aaa | debounce(300)\"/&gt;&#123;&#123;@aaa&#125;&#125; 300ms同步一次.另外,可编辑元素的用法与过滤器与上面三种控件一样.12&lt;div contenteditable=\"true\" ms-duplex=\"@aaa | debounce(300)\"/&gt;&lt;/div&gt;&lt;p&gt;&#123;&#123;@aaa&#125;&#125;&lt;/p&gt; 这两个过滤器只能适用于上面的情况.此外, 控件还有许多种, 像checkbox, radio,它们的同步机制也不一样.123456789101112131415161718&lt;body ms-controller=\"test\"&gt; &lt;script&gt; avalon.define(&#123; $id: 'test', aaa: '33', bbb: ['22'] &#125;) &lt;/script&gt; &lt;input type=\"radio\" value=\"11\" ms-duplex=\"@aaa\"/&gt; &lt;input type=\"radio\" value=\"22\" ms-duplex=\"@aaa\"/&gt; &lt;input type=\"radio\" value=\"33\" ms-duplex=\"@aaa\"/&gt; &lt;input type=\"checkbox\" value=\"11\" ms-duplex=\"@bbb\"/&gt; &lt;input type=\"checkbox\" value=\"22\" ms-duplex=\"@bbb\"/&gt; &lt;input type=\"checkbox\" value=\"33\" ms-duplex=\"@bbb\"/&gt; &lt;p&gt;radio: &#123;&#123;@aaa&#125;&#125;; checkbox:&#123;&#123;@bbb&#125;&#125;&lt;/p&gt;&lt;/body&gt; checkbox与radio是一点击就会更新.radio要求在vm中为一个简单数据类型数据,字符串,数字或布尔. 而checkbox则要求是一个数组.并且在最开始时,ms-duplex会令radio钩上其value值等vm属性的控件, checkbox则可以勾选多个.如此一来,vm中的属性些总是等于radio与checkbox的属性值.但我们也可以让 vm的属性值等于此控件的勾选状态,这时需要用上ms-duplex-checked转换器.12345678910111213&lt;body ms-controller=\"test\"&gt; &lt;script&gt; avalon.define(&#123; $id: 'test', aaa: false, bbb: false &#125;) &lt;/script&gt; &lt;input type=\"radio\" ms-duplex-checked=\"@aaa\"/&gt; &lt;input type=\"checkbox\" ms-duplex-checked=\"@bbb\"/&gt; &lt;p&gt;radio: &#123;&#123;@aaa&#125;&#125;; checkbox:&#123;&#123;@bbb&#125;&#125;&lt;/p&gt;&lt;/body&gt; 最后表单元素还有select控件,它根据其multiple属性分为单选下拉框与复选下拉框, 其在vm中的值与radio,checkbox一样.即单选时,必须是一个简单数据类型, 复选时为一个数组. 在最开始时, 当option元素的value值或innerText(不在value值)与数据相同,它们就会被选上.123456789101112&lt;body ms-controller=\"test\"&gt; &lt;script&gt; avalon.define(&#123; $id: 'test', aaa: 'bbb', bbb: ['bbb','ccc'], &#125;) &lt;/script&gt; &lt;select :duplex=\"@aaa\"&gt;&lt;option&gt;aaa&lt;/option&gt;&lt;option&gt;bbb&lt;/option&gt;&lt;option&gt;ccc&lt;/option&gt;&lt;/select&gt; &lt;select multiple=\"true\" :duplex=\"@bbb\"&gt;&lt;option&gt;aaa&lt;/option&gt;&lt;option&gt;bbb&lt;/option&gt;&lt;option&gt;ccc&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;","categories":[{"name":"avalon","slug":"avalon","permalink":"writebugs.cn/categories/avalon/"}],"tags":[{"name":"avalon","slug":"avalon","permalink":"writebugs.cn/tags/avalon/"}]},{"title":"node入门二","slug":"nodeJS(二)","date":"2018-06-24T16:00:00.000Z","updated":"2018-06-25T02:18:41.301Z","comments":true,"path":"nodeJS(二)/","link":"","permalink":"writebugs.cn/nodeJS(二)/","excerpt":"","text":"express12345678910111213141516171819202122232425262728293031const express=require('express');const expressStatic=require('express-static');var server=express();server.listen(8080);//用户数据var users=&#123; 'blue': '123456', 'zhangsan': '654321', 'lisi': '987987'&#125;;server.get('/login', function (req, res)&#123; var user=req.query['user']; var pass=req.query['pass']; if(users[user]==null)&#123; res.send(&#123;ok: false, msg: '此用户不存在'&#125;); &#125;else&#123; if(users[user]!=pass)&#123; res.send(&#123;ok: false, msg: '密码错了'&#125;); &#125;else&#123; res.send(&#123;ok: true, msg: '成功'&#125;); &#125; &#125;&#125;);server.use(expressStatic('./www'),function(req,res)&#123; res.send(\"ok\");&#125;); body-parser1234567891011121314151617181920212223242526const express=require('express');const querystring=require('querystring');const bodyParser=require('body-parser');var server=express();server.listen(8080);/*server.use(function (req, res, next)&#123; var str=''; req.on('data', function (data)&#123; str+=data; &#125;); req.on('end', function ()&#123; req.body=querystring.parse(str); next(); &#125;);&#125;);*/server.use(bodyParser.urlencoded(&#123;&#125;));server.use('/', function (req, res)&#123; console.log(req.body);&#125;);","categories":[{"name":"前端后台开发","slug":"前端后台开发","permalink":"writebugs.cn/categories/前端后台开发/"}],"tags":[{"name":"node","slug":"node","permalink":"writebugs.cn/tags/node/"}]},{"title":"node入门一","slug":"nodeJS(一)","date":"2018-06-21T16:00:00.000Z","updated":"2018-06-25T02:18:30.459Z","comments":true,"path":"nodeJS(一)/","link":"","permalink":"writebugs.cn/nodeJS(一)/","excerpt":"","text":"http1234567891011121314151617181920212223const http=require('http');var server=http.createServer(function (req, res)&#123;//req:require res:response switch(req.url)&#123; case '/1.html': res.write(\"111111\"); break; case '/2.html': res.write(\"2222\"); break; default: res.write('404'); break; &#125; console.log(req.url) res.end();&#125;);//监听——等着//端口-数字server.listen(8080);//http://localhost:8080/ fs12345678910111213141516171819202122const http=require('http');const fs=require('fs');var server=http.createServer(function (req, res)&#123; //req.url=&gt;'/index.html' //读取=&gt;'./www/index.html' // './www'+req.url var file_name='./www'+req.url; fs.readFile(file_name, function (err, data)&#123;//file_name:读取地址 if(err)&#123; res.write('404');//如果未找到 404 &#125;else&#123; res.write(data);//data：读取的文件内容 &#125; res.end(); &#125;);&#125;);server.listen(8080,function()&#123; console.log(\"ssss\");&#125;); url12345678910111213const http=require('http');const urlLib=require('url');http.createServer(function (req, res)&#123; var obj=urlLib.parse(req.url, true); var url=obj.pathname;//'./aaa' var GET=obj.query;//&#123;name:'33',pass:'22'&#125; console.log(url, GET); res.write('aaa'); res.end();&#125;).listen(8081); 登录注册实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const http=require('http');const fs=require('fs');const querystring=require('querystring');const urlLib=require('url');var users=&#123;&#125;; //&#123;\"blue\": \"123456\", \"zhangsan\": \"123456\", \"lisi\": \"321321\"&#125;var server=http.createServer(function (req, res)&#123; //解析数据 var str=''; req.on('data', function (data)&#123; str+=data; &#125;); req.on('end', function ()&#123; var obj=urlLib.parse(req.url, true); const url=obj.pathname; const GET=obj.query; const POST=querystring.parse(str); //区分——接口、文件 if(url=='/user')&#123; //接口 switch(GET.act)&#123; case 'reg': //1.检查用户名是否已经有了 if(users[GET.user])&#123; res.write('&#123;\"ok\": false, \"msg\": \"此用户已存在\"&#125;'); &#125;else&#123; //2.插入users users[GET.user]=GET.pass; res.write('&#123;\"ok\": true, \"msg\": \"注册成功\"&#125;'); &#125; break; case 'login': //1.检查用户是否存在 if(users[GET.user]==null)&#123; res.write('&#123;\"ok\": false, \"msg\": \"此用户不存在\"&#125;'); //2.检查用户密码 &#125;else if(users[GET.user]!=GET.pass)&#123; res.write('&#123;\"ok\": false, \"msg\": \"用户名或密码有误\"&#125;'); &#125;else&#123; res.write('&#123;\"ok\": true, \"msg\": \"登录成功\"&#125;'); &#125; break; default: res.write('&#123;\"ok\": false, \"msg\": \"未知的act\"&#125;'); &#125; res.end(); &#125;else&#123; //文件 //读取文件 var file_name='./www'+url; fs.readFile(file_name, function (err, data)&#123; if(err)&#123; res.write('404'); &#125;else&#123; res.write(data); &#125; res.end(); &#125;); &#125; &#125;);&#125;);server.listen(8080);","categories":[{"name":"前端后台开发","slug":"前端后台开发","permalink":"writebugs.cn/categories/前端后台开发/"}],"tags":[{"name":"node","slug":"node","permalink":"writebugs.cn/tags/node/"}]},{"title":"elementUI","slug":"element","date":"2018-06-03T16:00:00.000Z","updated":"2018-06-04T01:54:48.139Z","comments":true,"path":"element/","link":"","permalink":"writebugs.cn/element/","excerpt":"","text":"想要在ele表格中添加图片或非文字类，方法如下 12345&lt;el-table-column label=\"Logo\" width=\"100\"&gt; &lt;template scope=\"scope\"&gt; &lt;img :src=\"scope.row.Logo\" width=\"40\" height=\"40\" class=\"Logo\"/&gt; &lt;/template&gt;&lt;/el-table-column&gt; 其中Logo是你自己的定义参数","categories":[{"name":"前端UI","slug":"前端UI","permalink":"writebugs.cn/categories/前端UI/"}],"tags":[{"name":"elementUI","slug":"elementUI","permalink":"writebugs.cn/tags/elementUI/"}]},{"title":"webpack配置","slug":"webpack配置","date":"2018-04-14T16:00:00.000Z","updated":"2018-05-30T02:53:05.708Z","comments":true,"path":"webpack配置/","link":"","permalink":"writebugs.cn/webpack配置/","excerpt":"","text":"webpack配置官网 webpack官网地址: https://www.webpackjs.com此教程项目地址: https://github.com/lywnodejs/new/tree/master/webpack4.7 (拿到之后下载依赖 npm install) webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle 从 webpack v4.0.0 开始，可以不用引入一个配置文件。然而，webpack 仍然还是高度可配置的。在开始前你需要先理解四个核心概念： 入口(entry)输出(output)loader插件(plugins) 入口&amp;输出1234567891011121314151617181920const path=require('path');module.exports=&#123; entry:&#123; index:path.join(__dirname,'src/scripts/index.js'), index2:path.join(__dirname,'src/scripts/index2.js') &#125;, output:&#123; path:path.join(__dirname,'dist/js'), filename:'[name]-[chunkhash].js' //hash为本次打包的hash值 [chunkhash] 为保证文件唯一性，可以认为是文件的版本号 &#125;&#125;//打包单个 entry:&#123; index:\"./src/scripts/index.js\", index2:\"./src/scripts/index2.js\" &#125; 或者：entry:[\"src/script/index.js\".\"src/script/index2.js\"] output:&#123; filename:'dist/js/index.js' &#125; 执行webpack不想用webpack.config.js作为配置文件 可以在npm命令行中输入 webapck –config webpack.dev.config.js 此处webpack.dev.config.js为文件名配合npm 执行webpack ：在package.json中的scripts对象中添加“build”：“webpack –config webpack.config.js –progress –display-module –colors –display-reason” loaderhtml-webpack-plugin打包之后的HTML文件会自动插入打包后的js文件。如果html文件地址不对，请把output改为path:path.join(__dirname,’dist/‘)想要使src下的HTML与打包后的HTML文件相关联 html-webpack-plugin中传参数1234567891011new htmlWebpackPlugin(&#123; template:'./src/index.html',//模板文件 filename:'index.html',//输出html文件，同样可以指定文件名，设置hash值 inject:false,//将脚本放入head还是body title:\"webpack-app\",//html的标题 同时要在hmtl模板中的title中加入&lt;%= htmlWebpackpligin.options.title %&gt;此处必须是驼峰式命名，不然会报错 date:new Date(), minify:&#123; removeComments:true,//删除注释 collapseWhitespace:true //删除空格 &#125;&#125;) 多页面时 要分别引入不同的js文件 :123456789101112131415new htmlWebpackPlugin(&#123; template:'./src/index.html',//模板文件 filename:'index.html',//同样可以指定文件名，设置hash值 inject:'body',//将脚本放入head还是body title:\"webpack-app\",//html的标题同时要在hmtl模板中的title中加入&lt;%=htmlWebpackpligin.options.title%&gt;此处必须是驼峰式命名，不然会报错 chunks:['index'],//引入不同的脚本 excluedChunks:[a,c]排除不引用的脚本 &#125;),new htmlWebpackPlugin(&#123; template:'./src/index2.html', filename:'index2.html', inject:'body', title:\"webpack-app2\", chunks:['index'],&#125;) 将脚本直接写入html中123&lt;script type=\"text/javascript\"&gt; &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.index2.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source() %&gt;&lt;/script&gt; babel安装：npm install –save-dev babel-loader babel-core12345678910module:&#123; rules: [ &#123; test: /\\.js$/, use: 'babel-loader', include: path.resolve(__dirname,'src'),//加载哪个文件夹 exclude: path.resolve(__dirname,'node_modules')//排除哪个文件夹 &#125; ]&#125; style-loader!css-loader!postcss-loader12345678&#123; test: /\\.css$/, use:[ &#123;loader:'style-loader'&#125;, &#123;loader:'css-loader',options:&#123;improtLoaders:1&#125;&#125;, &#123;loader: \"postcss-loader\",options:&#123; plugins:[require('autoprefixer')]&#125;&#125;, ]&#125; 自动加浏览器前缀 postcss-loader &gt;autoprefixer 需要npm下载 less-loader 打包less文件 npm install less less-loader –save-dev123456789&#123; test:/\\.less$/, use: [ &#123;loader: \"style-loader\"&#125;, &#123;loader: \"css-loader\"&#125;, &#123;loader: \"postcss-loader\",options:&#123; plugins:[require('autoprefixer')]&#125;&#125;, &#123;loader: \"less-loader\"&#125; ]&#125; 打包sass和less一样 html-loader 打包html模板文件 npm install html-loader –save-dev123456&#123; test:/\\.html$/, use:[ &#123;loader:'html-loader'&#125; ]&#125; img-loader &amp; file-loader打包之前压缩图片 npm install image-webpack-loader –save-dev12345678910111213141516171819202122232425262728293031323334&#123;test:/\\.(png|gif|svg|jpg)$/i,use:[ &#123; loader:'url-loader', options:&#123; limit:10000, name:'images/[name].[ext]' &#125; &#125;, &#123; loader:'image-webpack-loader', options:&#123; mozjpeg: &#123; progressive: true, quality: 65 &#125;, optipng: &#123; enabled: false, &#125;, pngquant: &#123; quality: '65-90', speed: 4 &#125;, gifsicle: &#123; interlaced: false, &#125;, webp: &#123; quality: 75 &#125; &#125; &#125; ]&#125;, 以上教程根据webpack-4.7编写,亲测有效","categories":[{"name":"前端开发","slug":"前端开发","permalink":"writebugs.cn/categories/前端开发/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"writebugs.cn/tags/webpack/"},{"name":"前端模块化开发","slug":"前端模块化开发","permalink":"writebugs.cn/tags/前端模块化开发/"}]},{"title":"Array","slug":"数组操作","date":"2017-10-05T16:00:00.000Z","updated":"2018-06-25T02:53:55.122Z","comments":true,"path":"数组操作/","link":"","permalink":"writebugs.cn/数组操作/","excerpt":"","text":"POP 删除最后一项,并返回删除元素的值；如果数组为空则返回undefine1234var a = [1,2,3,4,5];a.pop();//a：[1, 2, 3, 4]a.pop();//a：[1, 2, 3]a.pop();//a：[1, 2] shift 删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefine123var a = [1,2,3,4,5]; a.shift(); //a：[2,3,4,5]a.shift(); //a：[3, 4, 5] push 增加到最后,并返回新数组长度1234var a = [1,2,3,4,5]; a.push(6);//[1, 2, 3, 4, 5, 6]aa.push('xx');//[1, 2, 3, 4, 5, 6, \"xx\"] 返回长度7a.push('yy');//[1, 2, 3, 4, 5, 6, \"xx\", \"yy\"] 返回长度8 unshift 增加到最前,并返回新数组长度1234var a = [1,2,3,4,5]; a.unshift();//[1, 2, 3, 4, 5]a.unshift(\"cc\");//[\"cc\", 1, 2, 3, 4, 5] 返回长度6a.unshift(\"aaa\");//[\"aaa\", \"cc\", 1, 2, 3, 4, 5] 返回长度7 reverse 数组翻转,并返回翻转后的原数组，原数组翻转了12var a = [1,2,3,4,5]; a.reverse()//a：[5, 4, 3, 2, 1] 返回[5, 4, 3, 2, 1] join 数组转成字符串,并返回字符串，原数组木变12var a = [1,2,3,4,5]; var b=a.join('||');//b:\"1||2||3||4||5\" a:[1,2,3,4,5] indexOf 数组元素索引,并返回元素索引，不存在返回-1,索引从0开始12345var a = ['a','b','c','d','e']; a.indexOf('a');//0a.indexOf(a);//-1a.indexOf('f');//-1a.indexOf('e');//4 slice 截取(切片)数组 得到截取的数组,返回从原数组中指定开始索引(包含)到结束索引(不包含)之间的项组成的新数组,原数组木变 ，索引从0开始1234var a = ['a','b','c','d','e']; a.slice(1,3);//[\"b\", \"c\"] a:['a','b','c','d','e']a.slice(0,4);//[\"a\", \"b\", \"c\", \"d\"]a.slice(3,4);//[\"d\"] splice 剪接数组 原数组变化 可以实现shift前删除，pop后删除,unshift前增加,同push后增加一样的效果12345678910111213141516171819/*参数是2个*///第一参数是索引（从0开始），第二是长度var a = ['a','b','c','d','e']; a.splice(0,2);//[\"a\", \"b\"] a:[\"c\", \"d\", \"e\"]a.splice(0,2);//[\"c\", \"d\"] a:[\"e\"]var a = ['a','b','c','d','e']; a.splice(0,1);//[\"a\"] a:[\"b\", \"c\", \"d\", \"e\"] 同shift前删除var a = ['a','b','c','d','e']a.splice(a.length-1,1)l//[\"e\"] a:[\"a\", \"b\", \"c\", \"d\"] 同pop前删除/*参数大于2个*///splice(start,deleteCount,val1,val2,...)：从start位置开始删除deleteCount项，并从该位置起插入val1,val2,... var a = ['a','b','c','d','e']; a.splice(3,1,10,21,238,99);//[\"d\"] a:[\"a\", \"b\", \"c\", 10, 21, 238, 99, \"e\"]var a = ['a','b','c','d','e']; a.splice(a.length,100000000,88)//返回 [] 从最后元素后面的元素，截取长度任意个，肯定是空 a：[\"a\", \"b\", \"c\", \"d\", \"e\", 88] 同push后增加var a = ['a','b','c','d','e']; a.splice(a.length,0,88)//返回 [] 从最后元素后面的元素，截取长度任意个，肯定是空 a：[\"a\", \"b\", \"c\", \"d\", \"e\", 88] 同push后增加var a = ['a','b','c','d','e'];a.splice(0,0,88,99)//返回 [] 从第一个元素，截取长度0个 肯定是空 a:[88, 99, \"a\", \"b\", \"c\", \"d\", \"e\"] 同unshift前增加 concat 数组合并,返回合并后的新数组,原数组木变1234var a = ['a','b','c','d','e']; a.concat([88,99]);//[\"a\", \"b\", \"c\", \"d\", \"e\", 88, 99] a:[\"a\", \"b\", \"c\", \"d\", \"e\"]var b= [9999,10000]a.concat(b);// [\"a\", \"b\", \"c\", \"d\", \"e\", 9999, 10000] a:[\"a\", \"b\", \"c\", \"d\", \"e\"]","categories":[{"name":"前端开发","slug":"前端开发","permalink":"writebugs.cn/categories/前端开发/"}],"tags":[{"name":"Array","slug":"Array","permalink":"writebugs.cn/tags/Array/"}]},{"title":"string","slug":"字符串操作","date":"2017-10-05T16:00:00.000Z","updated":"2018-06-25T02:40:38.702Z","comments":true,"path":"字符串操作/","link":"","permalink":"writebugs.cn/字符串操作/","excerpt":"","text":"length 获取字符串长度12var str = \"hello world\";alert(str.length); 索引 通过下标获取字符串指定位置的字符，但是不能改变该索引对应的值12var str = \"hello world\"str[0] = \"H\";//不会影响str,但也不会报错 toUpperCase 将字符串全部转为大写，并返回原字符串不变12var str = \"hello world\";console.log(str.toUpperCase()); toLowerCase 将字符串全部变小写，并返回原字符串不变12var str = \"hello world\";alert(str.toLowerCase()); indexOf 搜索指定字符串出现的位置，接收两个参数，第一个参数表示要查找的元素，第二个参数表示要查找的位置，若找到则返回对应元素所在的位置，否则返回-11234var s = 'hello world!';alert(s.indexOf('World'));//返回-1alert(s.indexOf('o'));//返回4alert(s.indexOf('o',6));//从第六位开始查找，返回7 concat 将一个或多个字符串拼接起来，返回拼接到的新的字符串，原字符串不变1234var str1 = \"hello \";var res = str1.concat(\" world\",\"!\");alert(res);//返回hello world！alert(str1);//返回hello slice 返回被操作字符的子字符串，原字符串不变，接受两个参数，字符串的起始位置和结束位置，返回的字符串不包含结束位置的字符，第一个参数要小于第二个参数，否则返回””,若只有一个参数，返回起始位置到字符串结尾的所有字符串，若传递的参数为负数，将传入的负值与字符创的长度相加123456var str = \"hello world!\";alert(str.slice(3,7));//返回lo walert(str.slice(3));//返回lo world!alert(str.slice(9,5));//返回\"\"alert(str.slice(-7,-3));//负数与长度相加，即str.slice(5,9)返回 woralert(str.slice(5,9));//返回 wor substring 当传入的参数是正数时，substring与slice的功能基本相同，唯一的区别是当第一个参数大于第二个参数时，方法将第二个参数作为截取的起始位置而将第一个参数作为截取结束的位置，且截取的字符串不包含第一个参数位置对应的值，当传入的参数是负值时，该方法会将所有的负值转化为0123456var str = \"hello world!\";alert(str.substring(3,7));//返回lo walert(str.substring(3));//返回lo world!alert(str.substring(9,5));//返回 wor,即str.substring(5,9),不包含第九项alert(str.substring(-7,-3));//负数与长度相加，即str.substring(0,0)返回\"\"alert(str.substring(-7,3));//负数与长度相加，即str.substring(0,3)返回hel substr 返回指定位置开始的指定长度的字符串，原字符串不变，若第二个参数缺省就一直截取到字符串结束，当传递的参数为负值时，方法会将负的第一个参数与字符串的长度相加，将负的第二个参数转化为012345var s = 'hello world!'alert(s.substr(0, 5));//从索引0开始，截取5个字符串，返回helloalert(s.substr(7)); //从索引7开始截取，一直到结束，返回orld!alert(s.substr(-7,3));//负数与长度相加，即str.substr(5,3),返回 woalert(s.substr(-7,-3));//负数与长度相加，即str.substr(5,0),返回\"\" split 基于指定的分隔符将一个字符串分割成多个字符串，并将结果存放在一个数组中，可以传两个参数，第一个参数为分隔符，第二个参数用于指定返回数组的大小，若省略该参数，则返回整个数组12345var s = \"1,23,45\";var arr1 = s.split(\",\");alert(arr1);//返回数组[\"1\",\"23\",\"45\"]var arr2 = s.split(\",\",2);alert(arr2);//返回数组[\"1\",\"23\"] trim 删除元素前置及后缀的所有空格，然后返回结果，原数组不变1234var str1 = \" hello world \";var str2 = str1.trim();alert(str1);//返回\" hello world \"alert(str2);//返回\"hello world\"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"writebugs.cn/categories/前端开发/"}],"tags":[{"name":"string","slug":"string","permalink":"writebugs.cn/tags/string/"}]},{"title":"vue安装第三方插件","slug":"vue全局使用第三方插件","date":"2017-09-19T16:00:00.000Z","updated":"2018-06-14T06:18:27.561Z","comments":true,"path":"vue全局使用第三方插件/","link":"","permalink":"writebugs.cn/vue全局使用第三方插件/","excerpt":"","text":"##使用VUE的过程中，需要引用第三方插件jquery，我们在使用jquery时，可以直接通过script标签引入，但是这种方法并不是全局方式，需要在每一个vue组件都去引用才可以生效，为了使用简单，我们现在可以通过以下方式来配置全局的jquery使用。 方法： 1.首先，安装jquery插件1npm install jquery –save 2.打开配置文件：build/webpack.base.conf.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091'use strict'const path = require('path')const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const vueLoaderConfig = require('./vue-loader.conf')function resolve (dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; context: path.resolve(__dirname, '../'), entry: &#123; app: './src/main.js' &#125;, output: &#123; path: config.build.assetsRoot, filename: '[name].js', publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), &#125; &#125;, plugins:[ new webpack.ProvidePlugin(&#123; jquery:\"jquery\", jQuery:\"jquery\", $:\"jquery\", \"window.jquery\":\"jquery\", &#125;) ], module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')] &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;, node: &#123; // prevent webpack from injecting useless setImmediate polyfill because Vue // source contains it (although only uses it if it's native). setImmediate: false, // prevent webpack from injecting mocks to Node native modules // that does not make sense for the client dgram: 'empty', fs: 'empty', net: 'empty', tls: 'empty', child_process: 'empty' &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"writebugs.cn/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"writebugs.cn/tags/vue/"}]},{"title":"vuex状态管理(一)","slug":"vuex状态管理","date":"2017-05-29T16:00:00.000Z","updated":"2018-05-30T02:52:41.848Z","comments":true,"path":"vuex状态管理/","link":"","permalink":"writebugs.cn/vuex状态管理/","excerpt":"","text":"安装1npm install vuex --save 然后 , 在 main.js 中加入 :1234567import vuex from 'vuex'Vue.use(vuex);var store = new vuex.Store(&#123;//store对象 state:&#123; show:false &#125;&#125;) 再然后 , 在实例化 Vue对象时加入 store 对象 :1234567new Vue(&#123; el: '#app', router, store,//使用store template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 改变状态123console.log(this.$store.state.show)this.$store.state.show=true;console.log(this.$store.state.show)","categories":[{"name":"vuex","slug":"vuex","permalink":"writebugs.cn/categories/vuex/"}],"tags":[{"name":"vue","slug":"vue","permalink":"writebugs.cn/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"writebugs.cn/tags/vuex/"}]},{"title":"react初识","slug":"react初识","date":"2017-05-21T16:00:00.000Z","updated":"2018-05-30T02:52:30.010Z","comments":true,"path":"react初识/","link":"","permalink":"writebugs.cn/react初识/","excerpt":"","text":"React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西好用，就在2013年5月开源了 ReactDOM.render()ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 1234ReactDOM.render( &lt;h1&gt;hello world ！ &lt;/h1&gt;, document.getElementById(\"app\") //将h1插入到真是dom元素里) 下面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。1234567891011var names=[\"array\",\"number\",\"data\"] ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt;hello &#123;name&#125;&lt;/div&gt; ////上面代码的names变量是一个数组，结果 JSX 会把它的所有成员，添加到模版 &#125;) &#125; &lt;/div&gt;, document.getElementById(\"app\") ) React.createClass React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类123456789var Hello=React.createClass(&#123; render:function () &#123; return &lt;h1&gt;我是组件 &#123;this.props.name&#125;&lt;/h1&gt;;//组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取 &#125;&#125;);ReactDOM.render( &lt;Hello name=\"join\"/&gt;, document.getElementById(\"app\") ) 上面代码中，变量 Hello 就是一个组件类。模板插入 时，会自动生成 app 的一个实例.所有组件类都必须有自己的 render 方法，用于输出组件。注意，组件类的第一个字母必须大写，否则会报错，另外，组件类只能包含一个顶层标签，否则也会报错。添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。 this.props.children this.props.children 属性。它表示组件的所有子节点1234567891011121314151617181920var Hello2=React.createClass(&#123; render:function () &#123; return ( &lt;ol&gt; &#123; React.Children.map(this.props.children,function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ) &#125;&#125;)ReactDOM.render( &lt;Hello2&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/Hello2&gt;, document.body) 这里需要注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。 getDefaultProps &amp; PropTypes12345678910111213141516171819var MyTitle = React.createClass(&#123; getDefaultProps:function () &#123;//getDefaultProps 方法可以用来设置组件属性的默认值。 return &#123; title:\"hello world\" &#125;; &#125;, propTypes: &#123; title: React.PropTypes.string.isRequired, &#125;,//上面的Mytitle组件有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。 render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyTitle /&gt;, document.body //上面代码会输出\"Hello World\"。); ref 组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性12345678910111213141516171819var MyComponent = React.createClass(&#123; handleClick: function(value) &#123; this.refs.myTextInput.focus(); console.log(this.refs.myTextInput.value) &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type=\"text\" ref=\"myTextInput\" /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.body); 上面代码中，组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等 this.state 组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI123456789101112131415161718var Buttons=React.createClass(&#123; getInitialState:function () &#123; return &#123;live:true&#125; &#125;, handleClick:function () &#123; this.setState(&#123;live:!this.state.live&#125;) &#125;, render:function () &#123; var text=this.state.live ? \"你好\" : \"你们好\" return ( &lt;div onClick=&#123;this.handleClick&#125;&gt;&#123;text&#125;,&lt;/div&gt; ) &#125;&#125;)ReactDOM.render( &lt;Buttons/&gt;, document.body) 上面代码是一个 Buttons 组件，它的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 表单 用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取123456789101112131415161718192021var Input=React.createClass(&#123; getInitialState:function()&#123; return &#123;value:\"hello\"&#125;; &#125;, handleChange:function(event)&#123; this.setState(&#123;value:event.target.value&#125;); &#125;, render:function()&#123; var value=this.state.value; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; &#125;); ReactDOM.render( &lt;Input /&gt;, document.body ) 上面代码中，文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况，更多介绍请参考官方文档。 组件的生命周期 组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。componentWillMount()componentDidMount()componentWillUpdate(object nextProps, object nextState)componentDidUpdate(object prevProps, object prevState)componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用123456789101112131415161718192021222324var Hello=React.createClass(&#123; getInitialState:function () &#123; return &#123;opacity:1.0&#125; &#125;, componentDidMount:function ()&#123; this.timer=setInterval(function () &#123; var opacity=this.state.opacity; opacity-=0.1; if(opacity&lt;0.1)&#123;opacity=1.0&#125; this.setState(&#123; opacity:opacity &#125;) &#125;.bind(this),100) &#125;, render:function () &#123; return ( &lt;div style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;hello &#123;this.props.name&#125;&lt;/div&gt; ) &#125; &#125;) ReactDOM.render( &lt;Hello name=\"world\" /&gt;, document.body ) 上面代码在hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。 文档声明 转载自阮一峰的 React 入门实例教程","categories":[{"name":"react","slug":"react","permalink":"writebugs.cn/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"writebugs.cn/tags/react/"}]},{"title":"Ajax","slug":"Ajax","date":"2017-04-25T16:00:00.000Z","updated":"2018-05-30T02:50:42.575Z","comments":true,"path":"Ajax/","link":"","permalink":"writebugs.cn/Ajax/","excerpt":"","text":"ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。 ajax原理和XmlHttpRequest对象 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 首先，我们先来看看XMLHttpRequest这个对象的属性。 它的属性有： onreadystatechange 每次状态改变所触发事件的事件处理程序。 responseText 从服务器进程返回数据的字符串形式。 responseXML 从服务器进程返回的DOM兼容的文档数据对象。 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） status Text 伴随状态码的字符串信息 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误， 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//创建传输对象function createXHR()&#123; if(window.XMLHttpRequest)&#123; return new XMLHrrpRequest(); &#125; return new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;//obj &#123;name:huhu,age:18&#125; =&gt; \"name=huhu&amp;age=18\"//格式化参数function params(obj) &#123; var arr = []; for(var i in obj) &#123; var str = i + \"=\" + obj[i]; arr.push(str); &#125; arr.push((\"v=\" + Math.random()).replace(\".\", \"\")); return arr.join(\"&amp;\");&#125;function ajax(option)&#123; option = option || &#123;&#125;; option.url = option.url || ''; option.type = option.type.toUpperCase() || 'GET'; option.data = option.data || ''; option.async = option.async || true; option.success = option.success || function (data) &#123;&#125;; option.error = option.errro || function (data) &#123;&#125;; // 第一步 创建对象 var xhr = createXHR(); //连接 和 发送 - 第二步 if (option.type == \"GET\") &#123; xhr.open(\"GET\", option.url + \"?\" + params(option.data), option.async); xhr.send(null); &#125; else if (option.type == \"POST\") &#123; xhr.open(\"POST\", option.url, option.async); //设置表单提交时的内容类型 xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.send(params(option.data)); &#125;else&#123; alert('类型有误') return; &#125; xhr.onreadystatechange = function () &#123; if (XHR.readyState == 4) &#123; var status = xhr.status; if (XHR.status &gt;= 200 &amp;&amp; XHR.status &lt; 300 || XHR.status == 304) &#123; switch (obj.responseType) &#123; case 'document': obj.success(XHR.responseXML); break; case 'json': obj.success(XHR.response); break; default: obj.success(XHR.responseText); break; &#125; &#125;else&#123; option.error(status); &#125; &#125; &#125;&#125;/* 使用 ajax(&#123; type:请求的方式 get/post 如果省略 默认是get, url:不能省略 必须参数 服务器地址, data:&#123;&#125; 参数 如果没有参数省略即可, async: ture/false 是否是异步 默认不写就是异步, success:function(data)&#123;&#125; 请求成功的回调函数 data表示请求回来的数据, error:function(data)&#123;&#125; 请求失败的回调函数, responseType:document(请求xml数据) json(请求json数据) text 如果省略默认返回text &#125;);*/ 还有其他封装方法 不一一列出了~ Ajax的缺点下面所阐述的ajax的缺陷都是它先天所产生的。 1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。） 但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。 2、安全问题 技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。 5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。 6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"writebugs.cn/categories/前端开发/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"writebugs.cn/tags/Ajax/"}]},{"title":"vue中的路由懒加载","slug":"vue的路由懒加载","date":"2017-03-14T16:00:00.000Z","updated":"2018-05-30T02:52:55.384Z","comments":true,"path":"vue的路由懒加载/","link":"","permalink":"writebugs.cn/vue的路由懒加载/","excerpt":"","text":"##懒加载： 也叫延迟加载，即在需要的时候进行加载，随用随载。 为什么需要懒加载？ 像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时 简单的说就是：进入首页不用一次加载过多资源造成用时过长！！！ 如何实现？ 懒加载写法：12345678910111213141516171819202122232425262728293031import Vue from 'vue';import Router from 'vue-router';Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'login', component:resolve=&gt;require([\"@/components/login\"],resolve) &#125;, &#123; path: '/list', component:resolve=&gt;require([\"@/components/list/list\"],resolve), children:[ &#123; path: 'CuserManagement', name:\"C端用户管理\", component:resolve=&gt;require([\"@/components/CuserManagement\"],resolve) &#125;, &#123; path: 'BuserManagement', name:\"B端用户管理\", component:resolve=&gt;require([\"@/components/BuserManagement\"],resolve) &#125;, ] &#125;, ]&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"writebugs.cn/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"writebugs.cn/tags/vue/"}]},{"title":"vue中监听router变化","slug":"vue的router监听","date":"2017-03-09T16:00:00.000Z","updated":"2018-05-30T02:52:49.105Z","comments":true,"path":"vue的router监听/","link":"","permalink":"writebugs.cn/vue的router监听/","excerpt":"","text":"有时候我们需要监听路由，做出某种操作。。 ##下面是个简单的例子 ##1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;//添加到页面 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; data()&#123; return &#123; msg:\"\" &#125; &#125;, mounted()&#123; this.get() &#125;, methods:&#123; get()&#123; this.msg=this.$router.history.current.name &#125; &#125;, watch:&#123; $route:\"get\" //监听router变化 并立即改变data数据 &#125;&#125;//其中this.$router.history.current是当前路由 下面的参数根据需要变化&lt;/script&gt; 还有其他封装方法 不一一列出了~","categories":[{"name":"前端开发","slug":"前端开发","permalink":"writebugs.cn/categories/前端开发/"}],"tags":[{"name":"vue","slug":"vue","permalink":"writebugs.cn/tags/vue/"},{"name":"router","slug":"router","permalink":"writebugs.cn/tags/router/"}]},{"title":"attr prop 区别","slug":"attrAndProp","date":"2017-02-26T16:00:00.000Z","updated":"2018-05-30T02:51:33.804Z","comments":true,"path":"attrAndProp/","link":"","permalink":"writebugs.cn/attrAndProp/","excerpt":"","text":"jquery中attr和prop的区别在高版本的jquery引入prop方法后，什么时候该用prop？什么时候用attr？它们两个之间有什么区别？这些问题就出现了。 对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。 举几个例子就知道了。 1&lt;a href=\"http://www.baidu.com\" target=\"_self\" class=\"btn\"&gt;百度&lt;/a&gt; 这个例子里&lt;a&gt;元素的DOM属性有“href、target和class“，这些属性就是&lt;a&gt;元素本身就带有的属性，也是W3C标准里就包含有这几个属性，或者说在IDE里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用prop方法。 1&lt;a href=\"#\" id=\"link1\" action=\"delete\"&gt;删除&lt;/a&gt; 这个例子里&lt;a&gt;元素的DOM属性有“href、id和action”，很明显，前两个是固有属性，而后面一个“action”属性是我们自己自定义上去的，&lt;a&gt;元素本身是没有这个属性的。这种就是自定义的DOM属性。处理这些属性时，建议使用attr方法。使用prop方法取值和设置属性值时，都会返回undefined值。 再举一个例子： 12&lt;input id=\"chk1\" type=\"checkbox\" /&gt; //是否可见&lt;input id=\"chk2\" type=\"checkbox\" checked=\"checked\" /&gt; //是否可见 像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此需要使用prop方法去操作才能获得正确的结果。 12$(\"#chk1\").prop(\"checked\") == false$(\"#chk2\").prop(\"checked\") == true 如果上面使用attr方法，则会出现： 12$(\"#chk1\").attr(\"checked\") == undefined$(\"#chk2\").attr(\"checked\") == \"checked\"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"writebugs.cn/categories/前端开发/"}],"tags":[{"name":"attr","slug":"attr","permalink":"writebugs.cn/tags/attr/"},{"name":"prop","slug":"prop","permalink":"writebugs.cn/tags/prop/"}]},{"title":"ES6 Modules","slug":"ES6-Modules","date":"2017-02-10T16:00:00.000Z","updated":"2018-05-30T02:51:46.091Z","comments":true,"path":"ES6-Modules/","link":"","permalink":"writebugs.cn/ES6-Modules/","excerpt":"","text":"ES6正式提出了内置的模块化语法，我们在浏览器端无需额外引入requirejs来进行模块化。 ES6中的模块有以下特点： 模块自动运行在严格模式下 在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在； 模块顶级作用域的 this 值为 undefined 对于需要让模块外部代码访问的内容，模块必须导出它们 定义模块使用 export 关键字将任意变量、函数或者类公开给其他模块。123456789101112131415161718192021222324//导出变量export var color = \"red\";export let name = \"cz\";export const age = 25;//导出函数export function add(num1,num2)&#123; return num1+num2;&#125;//导出类export class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125;&#125;function multiply(num1, num2) &#123; return num1 * num2;&#125;//导出对象，即导出引用export &#123;multiply&#125; 重命名模块重命名想导出的变量、函数或类的名称12345function sum(num1, num2) &#123; return num1 + num2;&#125;export &#123;sum as add&#125; 这里将本地的sum函数重命名为add导出，因此在使用此模块的时候必须使用add这个名称。 导出默认值模块的默认值是使用 default 关键字 所指定的单个变量、函数或类，而你在每个模块中 只能设置一个默认导出。 123export default function(num1, num2) &#123; return num1 + num2;&#125; 此模块将一个函数作为默认值进行了导出， default 关键字标明了这是一个默认导出。此函数并不需要有名称，因为它就代表这个模块自身。对比最前面使用export导出的函数，并不是匿名函数而是必须有一个名称用于加载模块的时候使用，但是默认导出则无需一个名字，因为模块名就代表了这个导出值。 也可以使用重命名语法来导出默认值。12345function sum(num1, num2) &#123; return num1 + num2;&#125;export &#123; sum as default &#125;; 加载模块在模块中使用 import 关键字来导入其他模块。import 语句有两个部分，一是需要导入的标识符，二是需导入的标识符的来源模块。此处是导入语句的基本形式：1import &#123; identifier1,identifier2 &#125; from \"./example.js\" 大括号中指定了从给定模块导入的标识符 from指明了需要导入的模块。模块由一个表示模块路径的字符串来指定。 当从模块导入了一个绑定时，你不能在当前文件中再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的 import 语句之前使用此标识符，更不能修改它的值。 导入单个绑定如果一个模块只导出了一个函数（或变量或类），或者导出了多个接口但是只选择导入其中的一个，那么就可以写成下面单个导入的模式： 1import &#123;sum&#125; from './example.js' 完全导入一个模块还有一种情况，就是将整个模块当做单一对象导入，该模块的所有导出都会作为对象的属性存在： 123import * as example from './example.js'example.sum(1,2);example.multiply(2,3); 在此代码中， example.js 中所有导出的绑定都被加载到一个名为 example 的对象中，具名导出（ sum() 函数、 multiple() 函数）都成为 example 的可用属性。这种导入格式被称为 命名空间导入 ，这是因为该 example 对象并不存在于 example.js 文件中，而是作为一个命名空间对象被创建使用，其中包含了 example.js 的所有导出成员。1然而要记住，无论你对同一个模块使用了多少次 import 语句，该模块都只会被执行一次。 在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 import 所引用. 123import &#123; sum &#125; from \"./example.js\";import &#123; multiply &#125; from \"./example.js\";import &#123; magicNumber &#125; from \"./example.js\"; 尽管此处的模块使用了三个 import 语句，但 example.js 只会被执行一次。若同一个应用中的其他模块打算从 example.js 导入绑定，则那些模块都会使用这段代码中所用的同一个模块实例。 重命名导入与导出相同，我们同样可以重命名导入的绑定：1import &#123; sum as add&#125; from './example.js' 导入默认值如果一个模块导出了默认值，那么可以这样导入默认值： 1import sum from \"./example.js\"; 这个导入语句从 example.js 模块导入了其默认值。注意此处并未使用花括号，与之前在非默认的导入中看到的不同。本地名称 sum 被用于代表目标模块所默认导出的函数，因此无需使用花括号。 如果一个模块既导出了默认值、又导出了一个或更多非默认的绑定的模块：12345export let color = \"red\";export default function(num1, num2) &#123; return num1 + num2;&#125; 可以像下面这样使用一条import语句来导入它的所有导出绑定：1import sum,&#123;color&#125; from \"./example.js\" 逗号将默认的本地名称与非默认的名称分隔开，后者仍旧被花括号所包裹。要记住在 import 语句中 默认名称必须位于非默认名称之前。 导入的再导出有时想在当前的模块中将已导入的内容再导出去，可以像下面这样写：123import &#123;sum&#125; from './example.js'……export &#123;sum&#125; 但是有一种更简洁的方法： 1export &#123;sum&#125; from './example.js' 同样可以重命名：1export &#123; sum as add &#125; from \"./example.js\"; 也可以使用完全导出：1export * from \"./example.js\"; 限制export 与 import 都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部，而不能使用在if等代码块内部。原因之一是模块语法需要让 JS 能静态判断需要导出什么，正因为此，你只能在模块的顶级作用域使用 export与import。","categories":[{"name":"es6","slug":"es6","permalink":"writebugs.cn/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"writebugs.cn/tags/es6/"},{"name":"Modules","slug":"Modules","permalink":"writebugs.cn/tags/Modules/"}]},{"title":"ES6 Array扩展","slug":"es6新增array","date":"2017-02-09T16:00:00.000Z","updated":"2018-05-30T02:51:51.674Z","comments":true,"path":"es6新增array/","link":"","permalink":"writebugs.cn/es6新增array/","excerpt":"","text":"find : 1234567let arr=[1,2,234,'sdf',-2];arr.find(function(x)&#123; return x&lt;=2;&#125;)//结果：1，返回第一个符合条件的x值arr.find(function(x,i,arr)&#123; if(x&lt;2)&#123;console.log(x,i,arr)&#125;&#125;)//结果：1 0 [1, 2, 234, \"sdf\", -2]，-2 4 [1, 2, 234, \"sdf\", -2] find的参数为回调函数，回调函数可以接收3个参数，值x、索引i、数组arr，回调函数默认返回值x。 findIndex :1234567let arr=[1,2,234,'sdf',-2];arr.findIndex(function(x)&#123; return x&lt;=2;&#125;)//结果：0，返回第一个符合条件的x值的索引arr.findIndex(function(x,i,arr)&#123; if(x&lt;2)&#123;console.log(x,i,arr)&#125;&#125;)//结果：1 0 [1, 2, 234, \"sdf\", -2]，-2 4 [1, 2, 234, \"sdf\", -2] findIndex和find差不多，不过默认返回的是索引。 includes :1234let arr=[1,2,234,'sdf',-2];arr.includes(2);// 结果true，返回布尔值arr.includes(20);// 结果：false，返回布尔值arr.includes(2,3)//结果：false，返回布尔值 includes函数与string的includes一样，接收2参数，查询的项以及查询起始位置。 keys :1234let arr=[1,2,234,'sdf',-2];for(let a of arr.keys())&#123; console.log(a)&#125;//结果：0,1,2,3,4 遍历了数组arr的索引 keys，对数组索引的遍历 values :1234let arr=[1,2,234,'sdf',-2];for(let a of arr.values())&#123; console.log(a)&#125;//结果：1,2,234,sdf,-2 遍历了数组arr的值 values，对数组项的遍历 entries :1234567let arr=['w','b'];for(let a of arr.entries())&#123; console.log(a)&#125;//结果：[0,w],[1,b]for(let [i,v] of arr.entries())&#123; console.log(i,v)&#125;//结果：0 w,1 b entries，对数组键值对的遍历。 fill :1234let arr=['w','b'];arr.fill('i')//结果：['i','i']，改变原数组arr.fill('o',1)//结果：['i','o']改变原数组,第二个参数表示填充起始位置new Array(3).fill('k').fill('r',1,2)//结果：['k','r','k']，第三个数组表示填充的结束位置 fill方法改变原数组，当第三个参数大于数组长度时候，以最后一位为结束位置。 Array.of() :1234Array.of('w','i','r')//[\"w\", \"i\", \"r\"]返回数组Array.of(['w','o'])//[['w','o']]返回嵌套数组Array.of(undefined)//[undefined]依然返回数组Array.of()//[]返回一个空数组 Array.of()方法永远返回一个数组，参数不分类型，只分数量，数量为0返回空数组。 copyWithin :1234[\"w\", \"i\", \"r\"].copyWithin(0)//此时数组不变[\"w\", \"i\", \"r\"].copyWithin(1)//[\"w\", \"w\", \"i\"],数组从位置1开始被原数组覆盖，只有1之前的项0保持不变[\"w\", \"i\", \"r\",\"b\"].copyWithin(1,2)//[\"w\", \"r\", \"b\", \"b\"],索引2到最后的r,b两项分别替换到原数组1开始的各项，当数量不够，变终止[\"w\", \"i\", \"r\",'b'].copyWithin(1,2,3)//[\"w\", \"r\", \"r\", \"b\"]，强第1项的i替换为第2项的r copyWithin方法接收三个参数，被替换数据的开始处、替换块的开始处、替换块的结束处(不包括);copyWithin(s,m,n). Array.from() :12345678910Array.from(&#123;'0':'w','1':'b',length:2&#125;)//[\"w\", \"b\"],返回数组的长度取决于对象中的length，故此项必须有！Array.from(&#123;'0':'w','1':'b',length:4&#125;)//[\"w\", \"b\", undefined, undefined],数组后2项没有属性去赋值，故undefinedArray.from(&#123;'0':'w','1':'b',length:1&#125;)//[\"w\"],length小于key的数目，按序添加数组//////////////////////////////let divs=document.getElementsByTagName('div');Array.from(divs)//返回div元素数组Array.from('wbiokr')//[\"w\", \"b\", \"i\", \"o\", \"k\", \"r\"]Array.from([1,2,3],function(x)&#123; return x+1&#125;)//[2, 3, 4],第二个参数为回调函数 Array.from可以把带有lenght属性类似数组的对象转换为数组，也可以把字符串等可以遍历的对象转换为数组，它接收2个参数，转换对象与回调函数","categories":[{"name":"es6","slug":"es6","permalink":"writebugs.cn/categories/es6/"}],"tags":[{"name":"Array","slug":"Array","permalink":"writebugs.cn/tags/Array/"},{"name":"es6","slug":"es6","permalink":"writebugs.cn/tags/es6/"}]},{"title":"CommonJS规范","slug":"CommonJS规范","date":"2017-01-27T16:00:00.000Z","updated":"2018-05-30T02:51:42.021Z","comments":true,"path":"CommonJS规范/","link":"","permalink":"writebugs.cn/CommonJS规范/","excerpt":"","text":"定义模块在每个模块内部，module变量代表当前模块。它的exports属性是对外的接口，将模块的接口暴露出去。其他文件加载该模块，实际上就是读取module.exports变量。 123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 加载模块require方法用于加载模块，后缀名默认为.js 1var app = require('./app.js'); 模块加载的顺序，按照其在代码中出现的顺序 根据参数的不同格式，require命令去不同路径寻找模块文件。1) 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。2) 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件3) 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（node核心模块，或者通过全局安装或局部安装在node_modules目录中的模块） 入口文件一般都会有一个主文件（入口文件），在index.html中加载这个入口文件，然后在这个入口文件中加载其他文件。 可以通过在package.json中配置main字段来指定入口文件。 模块缓存第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。 加载机制CommonJS模块的加载机制是， 输入的是被输出的值的拷贝。 也就是说， 一旦输出一个值，模块内部的变化就影响不到这个值。 CommonJS 规范 CommonJs规范的出发点：JS没有模块系统、标准库较少、缺乏包管理工具；为了让JS可以在任何地方运行，以达到Java、C#、PHP这些后台语言具备开发大型应用的能力； 在CommonJs规范中： 一个文件就是一个模块，拥有单独的作用域； 普通方式定义的变量、函数、对象都属于该模块内； 通过require来加载模块； 通过exports和modul.exports来暴露模块中的内容； 所有代码都运行在模块作用域，不会污染全局作用域；模块可以多次加载，但只会在第一次加载的时候运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；模块的加载顺序，按照代码的出现顺序是同步加载的; dirname代表当前模块文件所在的文件夹路径，filename代表当前模块文件所在的文件夹路径+文件名; require（同步加载）基本功能：读取并执行一个JS文件，然后返回该模块的exports对象，如果没有发现指定模块会报错; 模块内的exports：为了方便，node为每个模块提供一个exports变量，其指向module.exports，相当于在模块头部加了这句话：var exports = module.exports，在对外输出时，可以给exports对象添加方法，PS：不能直接赋值（因为这样就切断了exports和module.exports的联系）; npm root -g：查看npm全局包安装位置，建议在nvm目录下新建npm\\node_modules目录，然后设置npm的全局包安装位置：npm config set prefix “”，然后将该路径添加到环境变量中; npm init -y：初始化一个package.json文件，加上-y就会默认生成该文件，无需一步一步填写；npm docs 包名：查看包的文档；npm install：安装package.json中dependencies属性中所有依赖的包 由于npm的服务器是国外的，所以如果你没有和谐工具是下载不了的，这里推荐使用淘宝NPM镜像：http://npm.taobao.org/，与官方NPM的同步频率目前为10分钟一次；安装命令：npm install -g cnpm –registry=https://registry.npm.taobao.org，安装包：cnpm install 包名（其它命令基本一致）; 如果你不想下载cnpm，npm还提供了一个镜像源管理工具：npm install -g nrm，通过：nrm ls，查看镜像源列表 ，通过：npm use 镜像源，来切换; NPM的模块加载机制： 如果require的是绝对路径文件，查找不会去遍历每个node_modules目录，其速度最快 1）.从module.paths数组中（由当前执行文件目录到磁盘根目录）取出第一个目录作为查找基准 2）.直接从目录中查找该文件，如果存在则结束查找，如果不存在则进行下一条查找 3）.尝试添加.js、.json、.node后缀之后查找，如果存在文件则结束查找，如果不存在则进行下一条查找 4）.尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得Main参数指定的文件 5）.尝试查找该文件，如果存在则结束查找，如果不存在则进行第3条查找 6）.如果继续失败，则取出module.paths数组中的下一目录作为基准查找，循环第1-5个步骤 7）.如果继续失败，循环第1-6个步骤，直到module.paths中的最后一个值 8）.如果继续失败，则抛出异常","categories":[{"name":"前端开发","slug":"前端开发","permalink":"writebugs.cn/categories/前端开发/"}],"tags":[{"name":"CommonJS","slug":"CommonJS","permalink":"writebugs.cn/tags/CommonJS/"}]},{"title":"Array方法","slug":"Array方法","date":"2017-01-11T16:00:00.000Z","updated":"2018-05-30T03:00:27.613Z","comments":true,"path":"Array方法/","link":"","permalink":"writebugs.cn/Array方法/","excerpt":"","text":"join()join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。1234var arr = [1,2,3];console.log(arr.join()); // 1,2,3console.log(arr.join(\"-\")); // 1-2-3console.log(arr); // [1, 2, 3]（原数组不变） 通过join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重复后的字符串，函数如下：12345function repeatString(str, n) &#123;return new Array(n + 1).join(str);&#125;console.log(repeatString(\"abc\", 3)); // abcabcabcconsole.log(repeatString(\"Hi\", 5)); // HiHiHiHiHi push()和pop()push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。1234567var arr = [\"Lily\",\"lucy\",\"Tom\"];var count = arr.push(\"Jack\",\"Sean\");console.log(count); // 5console.log(arr); // [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]var item = arr.pop();console.log(item); // Seanconsole.log(arr); // [\"Lily\", \"lucy\", \"Tom\", \"Jack\"] shift() 和 unshift()shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。unshift:将参数添加到原数组开头，并返回数组的长度 。 这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。1234567var arr = [\"Lily\",\"lucy\",\"Tom\"];var count = arr.unshift(\"Jack\",\"Sean\");console.log(count); // 5console.log(arr); //[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]var item = arr.shift();console.log(item); // Jackconsole.log(arr); // [\"Sean\", \"Lily\", \"lucy\", \"Tom\"] sort()sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。 在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：12345var arr1 = [\"a\", \"d\", \"c\", \"b\"];console.log(arr1.sort()); // [\"a\", \"b\", \"c\", \"d\"]arr2 = [13, 24, 51, 3];console.log(arr2.sort()); // [13, 24, 3, 51]console.log(arr2); // [13, 24, 3, 51](元数组被改变) 为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;arr2 = [13, 24, 51, 3];console.log(arr2.sort(compare)); // [3, 13, 24, 51] 如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;arr2 = [13, 24, 51, 3];console.log(arr2.sort(compare)); // [51, 24, 13, 3] reverse()reverse()：反转数组项的顺序。123var arr = [13, 24, 51, 3];console.log(arr.reverse()); //[3, 51, 24, 13]console.log(arr); //[3, 51, 24, 13](原数组改变) concat()concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。1234var arr = [1,3,5,7];var arrCopy = arr.concat(9,[11,13]);console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]console.log(arr); // [1, 3, 5, 7](原数组未被修改) 从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？123var arrCopy2 = arr.concat([9,[11,13]]);console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]console.log(arrCopy2[5]); //[11, 13] 上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。 slice()slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。12345678910var arr = [1,3,5,7,9,11];var arrCopy = arr.slice(1);var arrCopy2 = arr.slice(1,4);var arrCopy3 = arr.slice(1,-2);var arrCopy4 = arr.slice(-4,-1);console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)console.log(arrCopy); //[3, 5, 7, 9, 11]console.log(arrCopy2); //[3, 5, 7]console.log(arrCopy3); //[3, 5, 7]console.log(arrCopy4); //[5, 7, 9] arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。 splice()splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。 12345678910var arr = [1,3,5,7,9,11];var arrRemoved = arr.splice(0,2);console.log(arr); //[5, 7, 9, 11]console.log(arrRemoved); //[1, 3]var arrRemoved2 = arr.splice(2,0,4,6);console.log(arr); // [5, 7, 4, 6, 9, 11]console.log(arrRemoved2); // []var arrRemoved3 = arr.splice(1,1,2,4);console.log(arr); // [5, 2, 4, 4, 6, 9, 11]console.log(arrRemoved3); //[7] indexOf()和 lastIndexOf()indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。123456var arr = [1,3,5,7,7,5,3,1];console.log(arr.indexOf(5)); //2console.log(arr.lastIndexOf(5)); //5console.log(arr.indexOf(5,2)); //2console.log(arr.lastIndexOf(5,4)); //2console.log(arr.indexOf(\"5\")); //-1 forEach()forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。12345678910var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123;console.log(x + '|' + index + '|' + (a === arr));&#125;);// 输出为：// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true map()map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 下面代码利用map方法实现数组中每个数求平方。12345var arr = [1, 2, 3, 4, 5];var arr2 = arr.map(function(item)&#123;return item*item;&#125;);console.log(arr2); //[1, 4, 9, 16, 25] filter()filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];var arr2 = arr.filter(function(x, index) &#123;return index % 3 === 0 || x &gt;= 8;&#125;);console.log(arr2); //[1, 4, 7, 8, 9, 10] every()every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.every(function(x) &#123;return x &lt; 10;&#125;);console.log(arr2); //truevar arr3 = arr.every(function(x) &#123;return x &lt; 3;&#125;);console.log(arr3); // false some()some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.some(function(x) &#123;return x &lt; 3;&#125;);console.log(arr2); //truevar arr3 = arr.some(function(x) &#123;return x &lt; 1;&#125;);console.log(arr3); // false reduce()和 reduceRight()这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123;return prev + cur;&#125;,10);console.log(sum); //25","categories":[{"name":"前端开发","slug":"前端开发","permalink":"writebugs.cn/categories/前端开发/"}],"tags":[{"name":"Array","slug":"Array","permalink":"writebugs.cn/tags/Array/"}]},{"title":"class 类--初识","slug":"Class-类-初识","date":"2017-01-03T16:00:00.000Z","updated":"2018-05-30T03:00:23.319Z","comments":true,"path":"Class-类-初识/","link":"","permalink":"writebugs.cn/Class-类-初识/","excerpt":"","text":"类的声明定义一个类的一种方法是使用一个类声明。要声明一个类，你可以使用带有class关键字的类名 123456class Remou &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; &#125; 不存在变量提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 12345&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; &#125;&#125; 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 类的表达式一个 类表达式 是定义一个类的另一种方式。类表达式可以是被命名的或匿名的。赋予一个命名类表达式的名称是类的主体的本地名称。 123456789101112131415//匿名的类let Rou = class &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; &#125;//命名的类let Rou = class Remou&#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; &#125; 注意: 类表达式也同样受到类声明中提到的提升问题的困扰。 类的方法和定义 一个类的类体是一对花括号 {} 中的部分。这是你定义类成员的位置，如方法或构造函数。 严格模式 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter和setter都在严格模式下执行。 constructor 方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without 'new' 类的实例化对象生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。 与 ES5 一样，类的所有实例共享一个原型对象。12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。这也意味着，可以通过实例的__proto__属性为“类”添加方法。 __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // \"Oops\"p2.printName() // \"Oops\"var p3 = new Point(4,2);p3.printName() // \"Oops\" 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的proto属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 Class 表达式与函数一样，类也可以使用表达式的形式定义。12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在 Class 内部有定义。如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { /* ... */ };采用 Class 表达式，可以写出立即执行的 Class。1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // \"张三\" 上面代码中，person是一个立即执行的类的实例。私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 1234567891011121314151617const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。 123456789class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。(目前水平达不到先记录一下) 12345678910111213141516171819function selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); name属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 12class Point &#123;&#125;Point.name // \"Point\" name属性总是返回紧跟在class关键字后面的类名。Class 的取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。存值函数和取值函数是设置在属性的 Descriptor 对象上的。 1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, \"html\");\"get\" in descriptor // true\"set\" in descriptor // true 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。12345678910111213class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log('hello'); &#125; baz () &#123; console.log('world'); &#125;&#125;Foo.bar() // hello 上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。父类的静态方法，可以被子类继承。 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。静态方法也是可以从super对象上调用的。 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod() // \"hello, too\" Class 的静态属性和实例属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。 12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined new.target 属性new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 命令生成实例'); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 命令生成实例'); &#125;&#125;var person = new Person('张三'); // 正确var notAPerson = Person.call(person, '张三'); // 报错 上面代码确保构造函数只能通过new命令调用。 Class 内部调用new.target，返回当前 Class。 123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。 1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // 输出 false 上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。","categories":[{"name":"Class","slug":"Class","permalink":"writebugs.cn/categories/Class/"}],"tags":[{"name":"es6","slug":"es6","permalink":"writebugs.cn/tags/es6/"},{"name":"面向对象","slug":"面向对象","permalink":"writebugs.cn/tags/面向对象/"}]}]}